[
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Constant:out0",
    "variable:out0"
   ]
  ],
  "acu_lys_alias": [
   "variable"
  ],
  "src_acu_in_tensor_map": [],
  "ruler_name": "r_variable",
  "priority_tip": 0,
  "src_in_anchor": [],
  "src_ops_alias": [
   "Constant"
  ],
  "blob_map": {
   "variable": {
    "data": [
     "CODE",
     "np.array([self.tensor_to_numpy(tensor['Constant:out0'])])  if self.tensor_to_numpy(tensor['Constant:out0']).shape == () else self.tensor_to_numpy(tensor['Constant:out0'])"
    ]
   }
  },
  "pre_condition": null,
  "src_out_tensor": [
   "Constant:out0"
  ],
  "param_map": {
   "variable": {
    "is_scalar": [
     "BOOL",
     "CODE",
     "True if len(self.tensor_to_numpy_without_convert_0darry(tensor['Constant:out0']).shape) == 0 else False "
    ],
    "shape": [
     "ORIGIN",
     "CODE",
     "self.shape_pick(tensor['Constant:out0'])"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   4
  ],
  "src_acu_out_tensor_map": [
   [
    "Add:out0",
    "fullconnect:out0"
   ]
  ],
  "acu_lys_alias": [
   "fullconnect"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "fullconnect:in0"
   ]
  ],
  "ruler_name": "r_rsp_mm_add",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Reshape:in0"
   ]
  ],
  "src_ops_alias": [
   "Reshape",
   "MatMul",
   "Add",
   "Constant_0",
   "Constant_1"
  ],
  "blob_map": {
   "fullconnect": {
    "weight": [
     "CODE",
     "self.matmul_weight(tensor['Constant_0:out0'])"
    ],
    "bias": [
     "CODE",
     "self.tensor_to_numpy(tensor['Constant_1:out0'])"
    ]
   }
  },
  "pre_condition": [
   "__rule_func_additional_args = {\"in_tensor\": \"Reshape:out0\", \"weight\": \"Constant_0:out0\", \"bias\": \"Constant_1:out0\"}",
   "def r_mm_check_wb(self, node, tensor, in_tensor, weight, bias = None):",
   "    input_shape = self.shape_pick(tensor[in_tensor])",
   "    weight_shape = self.shape_pick(tensor[weight])",
   "    if len(input_shape) != 2 or len(weight_shape) != 2:",
   "        return False",
   "",
   "    if bias is not None:",
   "        bias_shape = self.shape_pick(tensor[bias])",
   "        weights = self.shape_pick(tensor[weight])[1]",
   "        if len(bias_shape) != 1 or weights != bias_shape[0]:",
   "            return False",
   "    return True",
   ""
  ],
  "src_out_tensor": [
   "Add:out0"
  ],
  "param_map": {
   "fullconnect": {
    "bias": [
     "BOOL",
     "VALUE",
     true
    ],
    "weights": [
     "INT",
     "CODE",
     "self.shape_pick(tensor['Constant_0:out0'])[1]"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Reshape:out0",
    "MatMul:in0"
   ],
   [
    "MatMul:out0",
    "Add:in0"
   ],
   [
    "Constant_0:out0",
    "MatMul:in1"
   ],
   [
    "Constant_1:out0",
    "Add:in1"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   5,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Add:out0",
    "fullconnect:out0"
   ]
  ],
  "acu_lys_alias": [
   "fullconnect"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "fullconnect:in0"
   ]
  ],
  "ruler_name": "r_rsp_mm_add_v5",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Reshape:in0"
   ]
  ],
  "src_ops_alias": [
   "Reshape",
   "MatMul",
   "Add",
   "Constant_0",
   "Constant_1",
   "Constant_2"
  ],
  "blob_map": {
   "fullconnect": {
    "weight": [
     "CODE",
     "self.matmul_weight(tensor['Constant_0:out0'])"
    ],
    "bias": [
     "CODE",
     "self.tensor_to_numpy(tensor['Constant_1:out0'])"
    ]
   }
  },
  "pre_condition": [
   "__rule_func_additional_args = {\"in_tensor\": \"Reshape:out0\", \"weight\": \"Constant_0:out0\", \"bias\": \"Constant_1:out0\"}",
   "def r_mm_check_wb(self, node, tensor, in_tensor, weight, bias = None):",
   "    input_shape = self.shape_pick(tensor[in_tensor])",
   "    weight_shape = self.shape_pick(tensor[weight])",
   "    if len(input_shape) != 2 or len(weight_shape) != 2:",
   "        return False",
   "",
   "    if bias is not None:",
   "        bias_shape = self.shape_pick(tensor[bias])",
   "        weights = self.shape_pick(tensor[weight])[1]",
   "        if len(bias_shape) != 1 or weights != bias_shape[0]:",
   "            return False",
   "    return True",
   ""
  ],
  "src_out_tensor": [
   "Add:out0"
  ],
  "param_map": {
   "fullconnect": {
    "bias": [
     "BOOL",
     "VALUE",
     true
    ],
    "weights": [
     "INT",
     "CODE",
     "self.shape_pick(tensor['Constant_0:out0'])[1]"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Reshape:out0",
    "MatMul:in0"
   ],
   [
    "MatMul:out0",
    "Add:in0"
   ],
   [
    "Constant_0:out0",
    "MatMul:in1"
   ],
   [
    "Constant_1:out0",
    "Add:in1"
   ],
   [
    "Constant_2:out0",
    "Reshape:in1"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": null,
  "src_acu_out_tensor_map": [
   [
    "Add:out0",
    "fullconnect:out0"
   ]
  ],
  "acu_lys_alias": [
   "fullconnect"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "fullconnect:in0"
   ]
  ],
  "ruler_name": "r_mm_add",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "MatMul:in0"
   ]
  ],
  "src_ops_alias": [
   "MatMul",
   "Add",
   "Constant_0",
   "Constant_1"
  ],
  "blob_map": {
   "fullconnect": {
    "weight": [
     "CODE",
     "self.matmul_weight(tensor['Constant_0:out0'])"
    ],
    "bias": [
     "CODE",
     "self.tensor_to_numpy(tensor['Constant_1:out0'])"
    ]
   }
  },
  "pre_condition": [
   "__rule_func_additional_args = {\"in_tensor\": \"I:out0\", \"weight\": \"Constant_0:out0\", \"bias\": \"Constant_1:out0\"}",
   "def r_mm_check_wb(self, node, tensor, in_tensor, weight, bias = None):",
   "    input_shape = self.shape_pick(tensor[in_tensor])",
   "    weight_shape = self.shape_pick(tensor[weight])",
   "    if len(input_shape) != 2 or len(weight_shape) != 2:",
   "        return False",
   "",
   "    if bias is not None:",
   "        bias_shape = self.shape_pick(tensor[bias])",
   "        weights = self.shape_pick(tensor[weight])[1]",
   "        if len(bias_shape) != 1 or weights != bias_shape[0]:",
   "            return False",
   "    return True",
   ""
  ],
  "src_out_tensor": [
   "Add:out0"
  ],
  "param_map": {
   "fullconnect": {
    "bias": [
     "BOOL",
     "VALUE",
     true
    ],
    "weights": [
     "INT",
     "CODE",
     "self.shape_pick(tensor['Constant_0:out0'])[1]"
    ]
   }
  },
  "src_inter_flow": [
   [
    "MatMul:out0",
    "Add:in0"
   ],
   [
    "Constant_0:out0",
    "MatMul:in1"
   ],
   [
    "Constant_1:out0",
    "Add:in1"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": null,
  "src_acu_out_tensor_map": [
   [
    "MatMul:out0",
    "fullconnect:out0"
   ]
  ],
  "acu_lys_alias": [
   "fullconnect"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "fullconnect:in0"
   ]
  ],
  "ruler_name": "r_mm",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "MatMul:in0"
   ]
  ],
  "src_ops_alias": [
   "MatMul",
   "Constant_0"
  ],
  "blob_map": {
   "fullconnect": {
    "weight": [
     "CODE",
     "self.matmul_weight(tensor['Constant_0:out0'])"
    ]
   }
  },
  "pre_condition": [
   "__rule_func_additional_args = {\"in_tensor\": \"I:out0\", \"weight\": \"Constant_0:out0\"}",
   "def r_mm_check_wb(self, node, tensor, in_tensor, weight, bias = None):",
   "    input_shape = self.shape_pick(tensor[in_tensor])",
   "    weight_shape = self.shape_pick(tensor[weight])",
   "    if len(input_shape) != 2 or len(weight_shape) != 2:",
   "        return False",
   "",
   "    if bias is not None:",
   "        bias_shape = self.shape_pick(tensor[bias])",
   "        weights = self.shape_pick(tensor[weight])[1]",
   "        if len(bias_shape) != 1 or weights != bias_shape[0]:",
   "            return False",
   "    return True",
   ""
  ],
  "src_out_tensor": [
   "MatMul:out0"
  ],
  "param_map": {
   "fullconnect": {
    "bias": [
     "BOOL",
     "VALUE",
     false
    ],
    "weights": [
     "INT",
     "CODE",
     "self.shape_pick(tensor['Constant_0:out0'])[1]"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant_0:out0",
    "MatMul:in1"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Gemm:out0",
    "matmul:out0"
   ]
  ],
  "acu_lys_alias": [
   "matmul"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "matmul:in0"
   ],
   [
    "I_1:out0",
    "matmul:in1"
   ]
  ],
  "ruler_name": "r_gemm",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Gemm:in0"
   ],
   [
    "I_1:out0",
    "Gemm:in1"
   ]
  ],
  "src_ops_alias": [
   "Gemm"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "Gemm:out0"
  ],
  "param_map": {
   "matmul": {
    "transpose_b": [
     "BOOL",
     "CODE",
     "False if self.attr_pick(node['Gemm'], 'transB', 0) == 0 else True"
    ],
    "transpose_a": [
     "BOOL",
     "CODE",
     "False if self.attr_pick(node['Gemm'], 'transA', 0) == 0 else True"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Gemm:out0",
    "fullconnect:out0"
   ]
  ],
  "acu_lys_alias": [
   "fullconnect"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "fullconnect:in0"
   ]
  ],
  "ruler_name": "r_gemm_2_fc",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Gemm:in0"
   ]
  ],
  "src_ops_alias": [
   "Gemm",
   "Constant_0"
  ],
  "blob_map": {
   "fullconnect": {
    "weight": [
     "CODE",
     "self.fc_weight(tensor['Constant_0:out0'], node['Gemm'])"
    ]
   }
  },
  "pre_condition": "len(self.query_inputs(node['Gemm'])) == 2 and self.attr_pick(node['Gemm'], 'transA', 0) == 0 and self.attr_pick(node['Gemm'], 'transB', 0) == 1",
  "src_out_tensor": [
   "Gemm:out0"
  ],
  "param_map": {
   "fullconnect": {
    "bias": [
     "BOOL",
     "VALUE",
     "False"
    ],
    "weights": [
     "INT",
     "CODE",
     "self.shape_pick(tensor['Constant_0:out0'])[0]"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant_0:out0",
    "Gemm:in1"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Gemm:out0",
    "fullconnect:out0"
   ]
  ],
  "acu_lys_alias": [
   "fullconnect"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "fullconnect:in0"
   ]
  ],
  "ruler_name": "r_gemm_2_fc_wb",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Gemm:in0"
   ]
  ],
  "src_ops_alias": [
   "Gemm",
   "Constant_0",
   "Constant_1"
  ],
  "blob_map": {
   "fullconnect": {
    "weight": [
     "CODE",
     "self.gemm_weight_blob(tensor['Constant_0:out0'], node['Gemm'], 'transB')"
    ],
    "bias": [
     "CODE",
     "self.tensor_to_numpy(tensor['Constant_1:out0']) * self.attr_pick(node['Gemm'], 'beta', 1.0)"
    ]
   }
  },
  "pre_condition": "len(self.query_inputs(node['Gemm'])) == 3 and self.attr_pick(node['Gemm'], 'transA', 0) == 0 and self.attr_pick(node['Gemm'], 'transB', 0) == 1",
  "src_out_tensor": [
   "Gemm:out0"
  ],
  "param_map": {
   "fullconnect": {
    "bias": [
     "BOOL",
     "VALUE",
     true
    ],
    "weights": [
     "INT",
     "CODE",
     "self.gemm_weights_param(tensor['Constant_0:out0'], node['Gemm'], 'transB')"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant_0:out0",
    "Gemm:in1"
   ],
   [
    "Constant_1:out0",
    "Gemm:in2"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Gemm:out0",
    "fullconnect:out0"
   ]
  ],
  "acu_lys_alias": [
   "fullconnect"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "fullconnect:in0"
   ]
  ],
  "ruler_name": "gemm_2_fc_notranspose",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "Gemm:in0"
   ]
  ],
  "src_ops_alias": [
   "Gemm",
   "Constant",
   "Constant_1"
  ],
  "blob_map": {
   "fullconnect": {
    "weight": [
     "CODE",
     "self.gemm_weight_blob(tensor['Constant:out0'], node['Gemm'], 'transB')"
    ],
    "bias": [
     "CODE",
     "self.tensor_to_numpy(tensor['Constant_1:out0']) * self.attr_pick(node['Gemm'], 'beta', 1.0)"
    ]
   }
  },
  "pre_condition": "self.attr_pick(node['Gemm'], 'transA', 0) == 0 and self.attr_pick(node['Gemm'], 'transB', 0) == 0",
  "src_out_tensor": [
   "Gemm:out0"
  ],
  "param_map": {
   "fullconnect": {
    "bias": [
     "BOOL",
     "VALUE",
     true
    ],
    "weights": [
     "INT",
     "CODE",
     "self.gemm_weights_param(tensor['Constant:out0'], node['Gemm'], 'transB')"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant:out0",
    "Gemm:in1"
   ],
   [
    "Constant_1:out0",
    "Gemm:in2"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   5
  ],
  "src_acu_out_tensor_map": [
   [
    "Gemm:out0",
    "fullconnect:out0"
   ]
  ],
  "acu_lys_alias": [
   "fullconnect"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "fullconnect:in0"
   ]
  ],
  "ruler_name": "r_gemm_2_fc_4d_wb_notranspose",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "Reshape:in0"
   ]
  ],
  "src_ops_alias": [
   "Gemm",
   "Reshape",
   "Reshape_1",
   "Constant",
   "Constant_1"
  ],
  "blob_map": {
   "fullconnect": {
    "weight": [
     "CODE",
     "self.gemm_weight_blob(tensor['Reshape_1:out0'], node['Gemm'], 'transB')"
    ],
    "bias": [
     "CODE",
     "self.tensor_to_numpy(tensor['Constant:out0']) * self.attr_pick(node['Gemm'], 'beta', 1.0)"
    ]
   }
  },
  "pre_condition": "self.attr_pick(node['Gemm'], 'transA', 0) == 0 and self.attr_pick(node['Gemm'], 'transB', 0) == 0",
  "src_out_tensor": [
   "Gemm:out0"
  ],
  "param_map": {
   "fullconnect": {
    "bias": [
     "BOOL",
     "VALUE",
     true
    ],
    "weights": [
     "INT",
     "CODE",
     "self.gemm_weights_param(tensor['Constant:out0'], node['Gemm'], 'transB')"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Reshape:out0",
    "Gemm:in0"
   ],
   [
    "Reshape_1:out0",
    "Gemm:in1"
   ],
   [
    "Constant:out0",
    "Gemm:in2"
   ],
   [
    "Constant_1:out0",
    "Reshape_1:in0"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   5,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Gemm:out0",
    "fullconnect:out0"
   ]
  ],
  "acu_lys_alias": [
   "fullconnect"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "fullconnect:in0"
   ]
  ],
  "ruler_name": "r_gemm_2_fc_4d_wb_notranspose_v5",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "Reshape:in0"
   ]
  ],
  "src_ops_alias": [
   "Gemm",
   "Reshape",
   "Reshape_1",
   "Constant",
   "Constant_1",
   "Constant_2",
   "Constant_3"
  ],
  "blob_map": {
   "fullconnect": {
    "weight": [
     "CODE",
     "self.gemm_weight_blob(tensor['Constant_2:out0'], node['Gemm'], 'transB',                     self.shape_pick(tensor['Reshape_1:out0']))"
    ],
    "bias": [
     "CODE",
     "self.tensor_to_numpy(tensor['Constant:out0']) * self.attr_pick(node['Gemm'], 'beta', 1.0)"
    ]
   }
  },
  "pre_condition": "self.attr_pick(node['Gemm'], 'transA', 0) == 0 and self.attr_pick(node['Gemm'], 'transB', 0) == 0",
  "src_out_tensor": [
   "Gemm:out0"
  ],
  "param_map": {
   "fullconnect": {
    "bias": [
     "BOOL",
     "VALUE",
     true
    ],
    "weights": [
     "INT",
     "CODE",
     "self.gemm_weights_param(tensor['Reshape_1:out0'], node['Gemm'], 'transB')"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Reshape:out0",
    "Gemm:in0"
   ],
   [
    "Reshape_1:out0",
    "Gemm:in1"
   ],
   [
    "Constant:out0",
    "Gemm:in2"
   ],
   [
    "Constant_1:out0",
    "Reshape:in1"
   ],
   [
    "Constant_2:out0",
    "Reshape_1:in0"
   ],
   [
    "Constant_3:out0",
    "Reshape_1:in1"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Gemm:out0",
    "fullconnect:out0"
   ]
  ],
  "acu_lys_alias": [
   "fullconnect"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "fullconnect:in0"
   ]
  ],
  "ruler_name": "r_gemm_2_fc_wb_bc",
  "priority_tip": 1,
  "src_in_anchor": [
   [
    "I:out0",
    "Gemm:in0"
   ]
  ],
  "src_ops_alias": [
   "Gemm",
   "Constant_0",
   "Constant_1"
  ],
  "blob_map": {
   "fullconnect": {
    "weight": [
     "CODE",
     "self.gemm_weight_blob(tensor['Constant_0:out0'], node['Gemm'], 'transB')"
    ],
    "bias": [
     "CODE",
     "np.ones(self.shape_pick(tensor['Constant_0:out0'])[0], dtype=np.float32)*               self.tensor_to_numpy(tensor['Constant_1:out0']) * self.attr_pick(node['Gemm'], 'beta', 1.0)"
    ]
   }
  },
  "pre_condition": "len(self.query_inputs(node['Gemm'])) == 3 and self.attr_pick(node['Gemm'], 'transA', 0) == 0 and self.attr_pick(node['Gemm'], 'transB', 0) == 1 and self.shape_pick(tensor['Constant_1:out0'])[0] == 1 ",
  "src_out_tensor": [
   "Gemm:out0"
  ],
  "param_map": {
   "fullconnect": {
    "bias": [
     "BOOL",
     "VALUE",
     true
    ],
    "weights": [
     "INT",
     "CODE",
     "self.gemm_weights_param(tensor['Constant_0:out0'], node['Gemm'], 'transB')"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant_0:out0",
    "Gemm:in1"
   ],
   [
    "Constant_1:out0",
    "Gemm:in2"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   4
  ],
  "src_acu_out_tensor_map": [
   [
    "Gemm:out0",
    "fullconnect:out0"
   ]
  ],
  "acu_lys_alias": [
   "fullconnect"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "fullconnect:in0"
   ]
  ],
  "ruler_name": "r_fullconnect_with_wbrsp",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "Gemm:in0"
   ]
  ],
  "src_ops_alias": [
   "Gemm",
   "Reshape",
   "Constant",
   "Constant_1"
  ],
  "blob_map": {
   "fullconnect": {
    "weight": [
     "CODE",
     "self.gemm_weight_blob(tensor['Constant_1:out0'], node['Gemm'], 'transB',                     self.shape_pick(tensor['Reshape:out0']))"
    ],
    "bias": [
     "CODE",
     "self.tensor_to_numpy(tensor['Constant:out0']) * self.attr_pick(node['Gemm'], 'beta', 1.0)"
    ]
   }
  },
  "pre_condition": "len(self.query_inputs(node['Gemm'])) == 3 and self.attr_pick(node['Gemm'], 'transA', 0) == 0 and self.attr_pick(node['Gemm'], 'transB', 0) == 1",
  "src_out_tensor": [
   "Gemm:out0"
  ],
  "param_map": {
   "fullconnect": {
    "bias": [
     "BOOL",
     "VALUE",
     true
    ],
    "weights": [
     "INT",
     "CODE",
     "self.gemm_weights_param(tensor['Reshape:out0'], node['Gemm'], 'transB')"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Reshape:out0",
    "Gemm:in1"
   ],
   [
    "Constant:out0",
    "Gemm:in2"
   ],
   [
    "Constant_1:out0",
    "Reshape:in0"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   5,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Gemm:out0",
    "fullconnect:out0"
   ]
  ],
  "acu_lys_alias": [
   "fullconnect"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "fullconnect:in0"
   ]
  ],
  "ruler_name": "fc_w@in0_t@in1_with_reshape",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "Gemm:in0"
   ]
  ],
  "src_ops_alias": [
   "Gemm",
   "Reshape",
   "Constant",
   "Constant_1",
   "Constant_2"
  ],
  "blob_map": {
   "fullconnect": {
    "weight": [
     "CODE",
     "self.gemm_weight_blob(tensor['Constant_1:out0'], node['Gemm'], 'transB',                     self.shape_pick(tensor['Reshape:out0']))"
    ],
    "bias": [
     "CODE",
     "self.tensor_to_numpy(tensor['Constant:out0']) * self.attr_pick(node['Gemm'], 'beta', 1.0)"
    ]
   }
  },
  "pre_condition": "len(self.query_inputs(node['Gemm'])) == 3 and self.attr_pick(node['Gemm'], 'transA', 0) == 0 and self.attr_pick(node['Gemm'], 'transB', 0) == 1",
  "src_out_tensor": [
   "Gemm:out0"
  ],
  "param_map": {
   "fullconnect": {
    "bias": [
     "BOOL",
     "VALUE",
     true
    ],
    "weights": [
     "INT",
     "CODE",
     "self.gemm_weights_param(tensor['Reshape:out0'], node['Gemm'], 'transB')"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Reshape:out0",
    "Gemm:in1"
   ],
   [
    "Constant:out0",
    "Gemm:in2"
   ],
   [
    "Constant_1:out0",
    "Reshape:in0"
   ],
   [
    "Constant_2:out0",
    "Reshape:in1"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": null,
  "src_acu_out_tensor_map": [
   [
    "Tanh:out0",
    "tanh:out0"
   ]
  ],
  "acu_lys_alias": [
   "tanh"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "tanh:in0"
   ]
  ],
  "ruler_name": "r_tanh",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Tanh:in0"
   ]
  ],
  "src_ops_alias": [
   "Tanh"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "Tanh:out0"
  ],
  "param_map": {},
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": null,
  "src_acu_out_tensor_map": [
   [
    "Relu:out0",
    "relu:out0"
   ]
  ],
  "acu_lys_alias": [
   "relu"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "relu:in0"
   ]
  ],
  "ruler_name": "r_relu",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Relu:in0"
   ]
  ],
  "src_ops_alias": [
   "Relu"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "Relu:out0"
  ],
  "param_map": {},
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   6,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Elu:out0",
    "elu:out0"
   ]
  ],
  "acu_lys_alias": [
   "elu"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "elu:in0"
   ]
  ],
  "ruler_name": "r_elu",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Elu:in0"
   ]
  ],
  "src_ops_alias": [
   "Elu"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "Elu:out0"
  ],
  "param_map": {
   "elu": {
    "alpha": [
     "FLOAT",
     "CODE",
     "self.attr_pick(node['Elu'], 'alpha', 1.0)"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   12,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Celu:out0",
    "celu:out0"
   ]
  ],
  "acu_lys_alias": [
   "celu"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "celu:in0"
   ]
  ],
  "ruler_name": "r_celu",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Celu:in0"
   ]
  ],
  "src_ops_alias": [
   "Celu"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "Celu:out0"
  ],
  "param_map": {
   "celu": {
    "alpha": [
     "FLOAT",
     "CODE",
     "self.attr_pick(node['Celu'], 'alpha', 1.0)"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": null,
  "src_acu_out_tensor_map": [
   [
    "Sigmoid:out0",
    "Sigmoid:out0"
   ]
  ],
  "acu_lys_alias": [
   "Sigmoid"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "Sigmoid:in0"
   ]
  ],
  "ruler_name": "r_sigmoid",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Sigmoid:in0"
   ]
  ],
  "src_ops_alias": [
   "Sigmoid"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "Sigmoid:out0"
  ],
  "param_map": {},
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": null,
  "src_acu_out_tensor_map": [
   [
    "HardSigmoid:out0",
    "hard_sigmoid:out0"
   ]
  ],
  "acu_lys_alias": [
   "hard_sigmoid"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "hard_sigmoid:in0"
   ]
  ],
  "ruler_name": "r_hard_sigmoid",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "HardSigmoid:in0"
   ]
  ],
  "src_ops_alias": [
   "HardSigmoid"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "HardSigmoid:out0"
  ],
  "param_map": {
   "hard_sigmoid": {
    "alpha": [
     "FLOAT",
     "CODE",
     "self.attr_pick(node['HardSigmoid'], 'alpha', 0.2)"
    ],
    "beta": [
     "FLOAT",
     "CODE",
     "self.attr_pick(node['HardSigmoid'], 'beta', 0.5)"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": null,
  "src_acu_out_tensor_map": [
   [
    "LeakyRelu:out0",
    "leakyrelu:out0"
   ]
  ],
  "acu_lys_alias": [
   "leakyrelu"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "leakyrelu:in0"
   ]
  ],
  "ruler_name": "r_leakrelu",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "LeakyRelu:in0"
   ]
  ],
  "src_ops_alias": [
   "LeakyRelu"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "LeakyRelu:out0"
  ],
  "param_map": {
   "leakyrelu": {
    "leaky_ratio": [
     "FLOAT",
     "CODE",
     "self.attr_pick(node['LeakyRelu'], 'alpha', 0.01)"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": null,
  "src_acu_out_tensor_map": [
   [
    "PRelu:out0",
    "prelu:out0"
   ]
  ],
  "acu_lys_alias": [
   "prelu"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "prelu:in0"
   ]
  ],
  "ruler_name": "r_prelu_with_reshape",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "PRelu:in0"
   ]
  ],
  "src_ops_alias": [
   "PRelu",
   "Reshape",
   "Constant",
   "Constant_1"
  ],
  "blob_map": {
   "prelu": {
    "a": [
     "CODE",
     "self.prelu_alpha(tensor['I_0:out0'], tensor['Reshape:out0'])"
    ]
   }
  },
  "pre_condition": null,
  "src_out_tensor": [
   "PRelu:out0"
  ],
  "param_map": {
   "prelu": {}
  },
  "src_inter_flow": [
   [
    "Reshape:out0",
    "PRelu:in1"
   ],
   [
    "Constant:out0",
    "Reshape:in0"
   ],
   [
    "Constant_1:out0",
    "Reshape:in1"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": null,
  "src_acu_out_tensor_map": [
   [
    "PRelu:out0",
    "prelu:out0"
   ]
  ],
  "acu_lys_alias": [
   "prelu"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "prelu:in0"
   ]
  ],
  "ruler_name": "r_prelu",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "PRelu:in0"
   ]
  ],
  "src_ops_alias": [
   "PRelu",
   "Constant_0"
  ],
  "blob_map": {
   "prelu": {
    "a": [
     "CODE",
     "self.prelu_alpha(tensor['I:out0'], tensor['Constant_0:out0'])"
    ]
   }
  },
  "pre_condition": null,
  "src_out_tensor": [
   "PRelu:out0"
  ],
  "param_map": {},
  "src_inter_flow": [
   [
    "Constant_0:out0",
    "PRelu:in1"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": null,
  "src_acu_out_tensor_map": [
   [
    "PRelu:out0",
    "prelu:out0"
   ]
  ],
  "acu_lys_alias": [
   "prelu"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "prelu:in0"
   ]
  ],
  "ruler_name": "r_prelu_unsqueeze",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "PRelu:in0"
   ]
  ],
  "src_ops_alias": [
   "PRelu",
   "Constant",
   "Unsqueeze"
  ],
  "blob_map": {
   "prelu": {
    "a": [
     "CODE",
     "self.prelu_alpha(tensor['I:out0'], tensor['Unsqueeze:out0'])"
    ]
   }
  },
  "pre_condition": null,
  "src_out_tensor": [
   "PRelu:out0"
  ],
  "param_map": {},
  "src_inter_flow": [
   [
    "Constant:out0",
    "Unsqueeze:in0"
   ],
   [
    "Unsqueeze:out0",
    "PRelu:in1"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Reciprocal:out0",
    "Divide:out0"
   ]
  ],
  "acu_lys_alias": [
   "variable",
   "Divide"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "Divide:in1"
   ]
  ],
  "ruler_name": "r_reciprocal",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "Reciprocal:in0"
   ]
  ],
  "src_ops_alias": [
   "Reciprocal"
  ],
  "blob_map": {
   "variable": {
    "data": [
     "CODE",
     "np.array([1], dtype=np.float32)"
    ]
   }
  },
  "pre_condition": null,
  "src_out_tensor": [
   "Reciprocal:out0"
  ],
  "param_map": {
   "variable": {}
  },
  "src_inter_flow": [],
  "acu_inter_flow": [
   [
    "variable:out0",
    "Divide:in0"
   ]
  ]
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": null,
  "src_acu_out_tensor_map": [
   [
    "Pow:out0",
    "pow:out0"
   ]
  ],
  "acu_lys_alias": [
   "pow"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "pow:in0"
   ],
   [
    "I_1:out0",
    "pow:in1"
   ]
  ],
  "ruler_name": "r_pow",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Pow:in0"
   ],
   [
    "I_1:out0",
    "Pow:in1"
   ]
  ],
  "src_ops_alias": [
   "Pow"
  ],
  "blob_map": {
   "pow": {}
  },
  "pre_condition": null,
  "src_out_tensor": [
   "Pow:out0"
  ],
  "param_map": {
   "pow": {}
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": null,
  "src_acu_out_tensor_map": [
   [
    "Equal:out0",
    "equal:out0"
   ]
  ],
  "acu_lys_alias": [
   "equal"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "equal:in0"
   ],
   [
    "I_1:out0",
    "equal:in1"
   ]
  ],
  "ruler_name": "r_equal",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Equal:in0"
   ],
   [
    "I_1:out0",
    "Equal:in1"
   ]
  ],
  "src_ops_alias": [
   "Equal"
  ],
  "blob_map": {
   "equal": {}
  },
  "pre_condition": null,
  "src_out_tensor": [
   "Equal:out0"
  ],
  "param_map": {
   "equal": {}
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": null,
  "src_acu_out_tensor_map": [
   [
    "Less:out0",
    "less:out0"
   ]
  ],
  "acu_lys_alias": [
   "less"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "less:in0"
   ],
   [
    "I_1:out0",
    "less:in1"
   ]
  ],
  "ruler_name": "r_less",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Less:in0"
   ],
   [
    "I_1:out0",
    "Less:in1"
   ]
  ],
  "src_ops_alias": [
   "Less"
  ],
  "blob_map": {
   "less": {}
  },
  "pre_condition": null,
  "src_out_tensor": [
   "Less:out0"
  ],
  "param_map": {
   "less": {}
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   12,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "LessOrEqual:out0",
    "less_equal:out0"
   ]
  ],
  "acu_lys_alias": [
   "less_equal"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "less_equal:in0"
   ],
   [
    "I_1:out0",
    "less_equal:in1"
   ]
  ],
  "ruler_name": "r_less_equal",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "LessOrEqual:in0"
   ],
   [
    "I_1:out0",
    "LessOrEqual:in1"
   ]
  ],
  "src_ops_alias": [
   "LessOrEqual"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "LessOrEqual:out0"
  ],
  "param_map": {},
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": null,
  "src_acu_out_tensor_map": [
   [
    "Conv:out0",
    "conv1d:out0"
   ]
  ],
  "acu_lys_alias": [
   "conv1d"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "conv1d:in0"
   ]
  ],
  "ruler_name": "r_conv1d",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Conv:in0"
   ]
  ],
  "src_ops_alias": [
   "Conv",
   "Constant_0",
   "Constant_1"
  ],
  "blob_map": {
   "conv1d": {
    "weight": [
     "CODE",
     "self.tensor_to_numpy(tensor['Constant_0:out0'])"
    ],
    "bias": [
     "CODE",
     "self.tensor_to_numpy(tensor['Constant_1:out0'])"
    ]
   }
  },
  "pre_condition": "len(self.shape_pick(tensor['Constant_0:out0'])) == 3",
  "src_out_tensor": [
   "Conv:out0"
  ],
  "param_map": {
   "conv1d": {
    "pad_method": [
     "STRING",
     "CODE",
     "'auto' if self.attr_pick(node['Conv'], 'pads', None)== None else 'padding_const'"
    ],
    "stride": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'strides', [1])[0]"
    ],
    "pad": [
     "INTS",
     "CODE",
     "[p for p in self.array_layout(self.attr_pick(node['Conv'], 'pads', [0, 0]), [0, 1])]"
    ],
    "ksize": [
     "INT",
     "PYFUNC",
     [
      "__rule_func_additional_args = {\"kernel_name\": \"Constant_0:out0\"}",
      "def r_conv1d_get_kernel_shape(self, node, tensor, kernel_name):",
      "    kernel_shape = self.attr_pick(node['Conv'], 'kernel_shape', None)",
      "    if kernel_shape is None:",
      "        kernel = self.tensor_to_numpy(tensor[kernel_name])",
      "        kernel_shape = kernel.shape",
      "        return kernel_shape[2]",
      "",
      "    return kernel_shape[0]",
      ""
     ]
    ],
    "group_number": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'group', 1)"
    ],
    "bias": [
     "BOOL",
     "VALUE",
     true
    ],
    "weights": [
     "INT",
     "CODE",
     "self.shape_pick(tensor['Constant_0:out0'])[0]"
    ],
    "padding": [
     "STRING",
     "CODE",
     "'SAME' if self.attr_pick(node['Conv'], 'auto_pad', 'NOTSET') in ['SAME_UPPER', 'SAME_LOWER'] else 'VALID' "
    ],
    "dilation": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'dilations') if isinstance(self.attr_pick(node['Conv'], 'dilations'), int) else self.attr_pick(node['Conv'], 'dilations')[0]"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant_0:out0",
    "Conv:in1"
   ],
   [
    "Constant_1:out0",
    "Conv:in2"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": null,
  "src_acu_out_tensor_map": [
   [
    "Conv:out0",
    "group_conv1d:out0"
   ]
  ],
  "acu_lys_alias": [
   "group_conv1d"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "group_conv1d:in0"
   ]
  ],
  "ruler_name": "r_group_conv1d",
  "priority_tip": 1,
  "src_in_anchor": [
   [
    "I:out0",
    "Conv:in0"
   ]
  ],
  "src_ops_alias": [
   "Conv",
   "Constant_0",
   "Constant_1"
  ],
  "blob_map": {
   "group_conv1d": {
    "weight": [
     "CODE",
     "self.tensor_to_numpy(tensor['Constant_0:out0'])"
    ],
    "bias": [
     "CODE",
     "self.tensor_to_numpy(tensor['Constant_1:out0'])"
    ]
   }
  },
  "pre_condition": [
   "def r_group_conv1d_pre_condition(self, node, tensor):",
   "    ret = False",
   "    if len(self.shape_pick(tensor['Constant_0:out0'])) == 3:",
   "        in_shape = self.shape_pick(tensor['I:out0'])",
   "        group_number = self.attr_pick(node['Conv'], 'group', 1)",
   "        if group_number > 1:",
   "            ret = True",
   "    return ret",
   ""
  ],
  "src_out_tensor": [
   "Conv:out0"
  ],
  "param_map": {
   "group_conv1d": {
    "pad_method": [
     "STRING",
     "CODE",
     "'auto' if self.attr_pick(node['Conv'], 'pads', None)== None else 'padding_const'"
    ],
    "stride": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'strides', [1])[0]"
    ],
    "pad": [
     "INTS",
     "CODE",
     "[p for p in self.array_layout(self.attr_pick(node['Conv'], 'pads', [0, 0]), [0, 1])]"
    ],
    "ksize": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'kernel_shape')[0]"
    ],
    "group_number": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'group', 1)"
    ],
    "bias": [
     "BOOL",
     "VALUE",
     true
    ],
    "weights": [
     "INT",
     "CODE",
     "self.shape_pick(tensor['Constant_0:out0'])[0]"
    ],
    "padding": [
     "STRING",
     "CODE",
     "'SAME' if self.attr_pick(node['Conv'], 'auto_pad', 'NOTSET') in ['SAME_UPPER', 'SAME_LOWER'] else 'VALID' "
    ],
    "dilation": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'dilations') if isinstance(self.attr_pick(node['Conv'], 'dilations'), int) else self.attr_pick(node['Conv'], 'dilations')[0]"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant_0:out0",
    "Conv:in1"
   ],
   [
    "Constant_1:out0",
    "Conv:in2"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": null,
  "src_acu_out_tensor_map": [
   [
    "Conv:out0",
    "depthwise_conv1d:out0"
   ]
  ],
  "acu_lys_alias": [
   "depthwise_conv1d"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "depthwise_conv1d:in0"
   ]
  ],
  "ruler_name": "r_depthwise_conv1d",
  "priority_tip": 2,
  "src_in_anchor": [
   [
    "I:out0",
    "Conv:in0"
   ]
  ],
  "src_ops_alias": [
   "Conv",
   "Constant_0",
   "Constant_1"
  ],
  "blob_map": {
   "depthwise_conv1d": {
    "weight": [
     "CODE",
     "self.tensor_to_numpy(tensor['Constant_0:out0'])"
    ],
    "bias": [
     "CODE",
     "self.tensor_to_numpy(tensor['Constant_1:out0'])"
    ]
   }
  },
  "pre_condition": [
   "def r_depthwise_conv1d_pre_condition(self, node, tensor):",
   "    ret = False",
   "    if len(self.shape_pick(tensor['Constant_0:out0'])) == 3:",
   "        in_shape = self.shape_pick(tensor['I:out0'])",
   "        group_number = self.attr_pick(node['Conv'], 'group', 1)",
   "        if group_number > 1 and group_number == in_shape[1]:",
   "            ret = True",
   "    return ret",
   ""
  ],
  "src_out_tensor": [
   "Conv:out0"
  ],
  "param_map": {
   "depthwise_conv1d": {
    "pad_method": [
     "STRING",
     "CODE",
     "'auto' if self.attr_pick(node['Conv'], 'pads', None)== None else 'padding_const'"
    ],
    "multiplier": [
     "INT",
     "CODE",
     "int(self.shape_pick(tensor['Constant_0:out0'])[0]/self.shape_pick(tensor['I:out0'])[1])"
    ],
    "stride": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'strides', [1])[0]"
    ],
    "pad": [
     "INTS",
     "CODE",
     "[p for p in self.array_layout(self.attr_pick(node['Conv'], 'pads', [0, 0]), [0, 1])]"
    ],
    "ksize": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'kernel_shape')[0]"
    ],
    "group_number": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'group', 1)"
    ],
    "bias": [
     "BOOL",
     "VALUE",
     true
    ],
    "weights": [
     "INT",
     "CODE",
     "self.shape_pick(tensor['Constant_0:out0'])[0]"
    ],
    "padding": [
     "STRING",
     "CODE",
     "'SAME' if self.attr_pick(node['Conv'], 'auto_pad', 'NOTSET') in ['SAME_UPPER', 'SAME_LOWER'] else 'VALID' "
    ],
    "dilation": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'dilations') if isinstance(self.attr_pick(node['Conv'], 'dilations'), int) else self.attr_pick(node['Conv'], 'dilations')[0]"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant_0:out0",
    "Conv:in1"
   ],
   [
    "Constant_1:out0",
    "Conv:in2"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": null,
  "src_acu_out_tensor_map": [
   [
    "Conv:out0",
    "conv1d:out0"
   ]
  ],
  "acu_lys_alias": [
   "conv1d"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "conv1d:in0"
   ]
  ],
  "ruler_name": "r_conv1d_no_bias",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Conv:in0"
   ]
  ],
  "src_ops_alias": [
   "Conv",
   "Constant_0"
  ],
  "blob_map": {
   "conv1d": {
    "weight": [
     "CODE",
     "self.tensor_to_numpy(tensor['Constant_0:out0'])"
    ]
   }
  },
  "pre_condition": "len(self.shape_pick(tensor['Constant_0:out0'])) == 3",
  "src_out_tensor": [
   "Conv:out0"
  ],
  "param_map": {
   "conv1d": {
    "pad_method": [
     "STRING",
     "CODE",
     "'auto' if self.attr_pick(node['Conv'], 'pads', None) == None else 'padding_const'"
    ],
    "stride": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'strides', [1])[0]"
    ],
    "pad": [
     "INTS",
     "CODE",
     "[p for p in self.array_layout(self.attr_pick(node['Conv'], 'pads', [0, 0]), [0, 1])]"
    ],
    "ksize": [
     "INT",
     "PYFUNC",
     [
      "__rule_func_additional_args = {\"kernel_name\": \"Constant_0:out0\"}",
      "def r_conv1d_get_kernel_shape(self, node, tensor, kernel_name):",
      "    kernel_shape = self.attr_pick(node['Conv'], 'kernel_shape', None)",
      "    if kernel_shape is None:",
      "        kernel = self.tensor_to_numpy(tensor[kernel_name])",
      "        kernel_shape = kernel.shape",
      "        return kernel_shape[2]",
      "",
      "    return kernel_shape[0]",
      ""
     ]
    ],
    "group_number": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'group', 1)"
    ],
    "bias": [
     "BOOL",
     "VALUE",
     false
    ],
    "weights": [
     "INT",
     "CODE",
     "self.shape_pick(tensor['Constant_0:out0'])[0]"
    ],
    "padding": [
     "STRING",
     "CODE",
     "'SAME' if self.attr_pick(node['Conv'], 'auto_pad', 'NOTSET') in ['SAME_UPPER', 'SAME_LOWER'] else 'VALID' "
    ],
    "dilation": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'dilations') if isinstance(self.attr_pick(node['Conv'], 'dilations'), int) else self.attr_pick(node['Conv'], 'dilations')[0]"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant_0:out0",
    "Conv:in1"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": null,
  "src_acu_out_tensor_map": [
   [
    "Conv:out0",
    "group_conv1d:out0"
   ]
  ],
  "acu_lys_alias": [
   "group_conv1d"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "group_conv1d:in0"
   ]
  ],
  "ruler_name": "r_group_conv1d_no_bias",
  "priority_tip": 1,
  "src_in_anchor": [
   [
    "I:out0",
    "Conv:in0"
   ]
  ],
  "src_ops_alias": [
   "Conv",
   "Constant_0"
  ],
  "blob_map": {
   "group_conv1d": {
    "weight": [
     "CODE",
     "self.tensor_to_numpy(tensor['Constant_0:out0'])"
    ]
   }
  },
  "pre_condition": [
   "def r_group_conv1d_pre_condition(self, node, tensor):",
   "    ret = False",
   "    if len(self.shape_pick(tensor['Constant_0:out0'])) == 3:",
   "        in_shape = self.shape_pick(tensor['I:out0'])",
   "        group_number = self.attr_pick(node['Conv'], 'group', 1)",
   "        if group_number > 1:",
   "            ret = True",
   "    return ret",
   ""
  ],
  "src_out_tensor": [
   "Conv:out0"
  ],
  "param_map": {
   "group_conv1d": {
    "pad_method": [
     "STRING",
     "CODE",
     "'auto' if self.attr_pick(node['Conv'], 'pads', None) == None else 'padding_const'"
    ],
    "stride": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'strides', [1])[0]"
    ],
    "pad": [
     "INTS",
     "CODE",
     "[p for p in self.array_layout(self.attr_pick(node['Conv'], 'pads', [0, 0]), [0, 1])]"
    ],
    "ksize": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'kernel_shape')[0]"
    ],
    "group_number": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'group', 1)"
    ],
    "bias": [
     "BOOL",
     "VALUE",
     false
    ],
    "weights": [
     "INT",
     "CODE",
     "self.shape_pick(tensor['Constant_0:out0'])[0]"
    ],
    "padding": [
     "STRING",
     "CODE",
     "'SAME' if self.attr_pick(node['Conv'], 'auto_pad', 'NOTSET') in ['SAME_UPPER', 'SAME_LOWER'] else 'VALID' "
    ],
    "dilation": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'dilations') if isinstance(self.attr_pick(node['Conv'], 'dilations'), int) else self.attr_pick(node['Conv'], 'dilations')[0]"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant_0:out0",
    "Conv:in1"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": null,
  "src_acu_out_tensor_map": [
   [
    "Conv:out0",
    "depthwise_conv1d:out0"
   ]
  ],
  "acu_lys_alias": [
   "depthwise_conv1d"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "depthwise_conv1d:in0"
   ]
  ],
  "ruler_name": "r_depthwise_conv1d_no_bias",
  "priority_tip": 2,
  "src_in_anchor": [
   [
    "I:out0",
    "Conv:in0"
   ]
  ],
  "src_ops_alias": [
   "Conv",
   "Constant_0"
  ],
  "blob_map": {
   "depthwise_conv1d": {
    "weight": [
     "CODE",
     "self.tensor_to_numpy(tensor['Constant_0:out0'])"
    ]
   }
  },
  "pre_condition": [
   "def r_depthwise_conv1d_pre_condition(self, node, tensor):",
   "    ret = False",
   "    if len(self.shape_pick(tensor['Constant_0:out0'])) == 3:",
   "        in_shape = self.shape_pick(tensor['I:out0'])",
   "        group_number = self.attr_pick(node['Conv'], 'group', 1)",
   "        if group_number > 1 and group_number == in_shape[1]:",
   "            ret = True",
   "    return ret",
   ""
  ],
  "src_out_tensor": [
   "Conv:out0"
  ],
  "param_map": {
   "depthwise_conv1d": {
    "pad_method": [
     "STRING",
     "CODE",
     "'auto' if self.attr_pick(node['Conv'], 'pads', None) == None else 'padding_const'"
    ],
    "multiplier": [
     "INT",
     "CODE",
     "int(self.shape_pick(tensor['Constant_0:out0'])[0]/self.shape_pick(tensor['I:out0'])[1])"
    ],
    "stride": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'strides', [1])[0]"
    ],
    "pad": [
     "INTS",
     "CODE",
     "[p for p in self.array_layout(self.attr_pick(node['Conv'], 'pads', [0, 0]), [0, 1])]"
    ],
    "ksize": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'kernel_shape')[0]"
    ],
    "group_number": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'group', 1)"
    ],
    "bias": [
     "BOOL",
     "VALUE",
     false
    ],
    "weights": [
     "INT",
     "CODE",
     "self.shape_pick(tensor['Constant_0:out0'])[0]"
    ],
    "padding": [
     "STRING",
     "CODE",
     "'SAME' if self.attr_pick(node['Conv'], 'auto_pad', 'NOTSET') in ['SAME_UPPER', 'SAME_LOWER'] else 'VALID' "
    ],
    "dilation": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'dilations') if isinstance(self.attr_pick(node['Conv'], 'dilations'), int) else self.attr_pick(node['Conv'], 'dilations')[0]"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant_0:out0",
    "Conv:in1"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": null,
  "src_acu_out_tensor_map": [
   [
    "Conv:out0",
    "convolution:out0"
   ]
  ],
  "acu_lys_alias": [
   "convolution"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "convolution:in0"
   ]
  ],
  "ruler_name": "r_conv",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Conv:in0"
   ]
  ],
  "src_ops_alias": [
   "Conv",
   "Constant_0",
   "Constant_1"
  ],
  "blob_map": {
   "convolution": {
    "weight": [
     "CODE",
     "self.tensor_to_numpy(tensor['Constant_0:out0'])"
    ],
    "bias": [
     "CODE",
     "self.tensor_to_numpy(tensor['Constant_1:out0'])"
    ]
   }
  },
  "pre_condition": null,
  "src_out_tensor": [
   "Conv:out0"
  ],
  "param_map": {
   "convolution": {
    "pad_method": [
     "STRING",
     "CODE",
     "'auto' if self.attr_pick(node['Conv'], 'pads', None) == None else 'padding_const'"
    ],
    "pad": [
     "INTS",
     "CODE",
     "[p for p in self.array_layout(self.attr_pick(node['Conv'], 'pads', [ 0, 0, 0, 0]), [0, 2, 1, 3])]"
    ],
    "group_number": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'group', 1)"
    ],
    "ksize_w": [
     "INT",
     "CODE",
     "self.shape_pick(tensor['Constant_0:out0'])[3]"
    ],
    "bias": [
     "BOOL",
     "VALUE",
     true
    ],
    "stride_h": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'strides', [1, 1])[0]"
    ],
    "stride_w": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'strides', [1, 1])[1]"
    ],
    "weights": [
     "INT",
     "CODE",
     "self.shape_pick(tensor['Constant_0:out0'])[0]"
    ],
    "dilation": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'dilations') if isinstance(self.attr_pick(node['Conv'], 'dilations'), int) else self.attr_pick(node['Conv'], 'dilations')[0]"
    ],
    "padding": [
     "STRING",
     "CODE",
     "'SAME' if self.attr_pick(node['Conv'], 'auto_pad', 'NOTSET') in ['SAME_UPPER', 'SAME_LOWER'] else 'VALID' "
    ],
    "ksize_h": [
     "INT",
     "CODE",
     "self.shape_pick(tensor['Constant_0:out0'])[2]"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant_0:out0",
    "Conv:in1"
   ],
   [
    "Constant_1:out0",
    "Conv:in2"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Conv:out0",
    "conv2d_op:out0"
   ]
  ],
  "acu_lys_alias": [
   "conv2d_op"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "conv2d_op:in0"
   ],
   [
    "I_1:out0",
    "conv2d_op:in1"
   ]
  ],
  "ruler_name": "r_conv2d_op",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "Conv:in0"
   ],
   [
    "I_1:out0",
    "Conv:in1"
   ]
  ],
  "src_ops_alias": [
   "Conv"
  ],
  "blob_map": {
   "conv2d_op": {}
  },
  "pre_condition": null,
  "src_out_tensor": [
   "Conv:out0"
  ],
  "param_map": {
   "conv2d_op": {
    "group_number": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'group', 1)"
    ],
    "pad": [
     "INTS",
     "CODE",
     "[p for p in self.array_layout(self.attr_pick(node['Conv'], 'pads', [ 0, 0, 0, 0]), [0, 2, 1, 3])]"
    ],
    "stride_h": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'strides', [1, 1])[0]"
    ],
    "stride_w": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'strides', [1, 1])[1]"
    ],
    "padding": [
     "STRING",
     "CODE",
     "'SAME' if self.attr_pick(node['Conv'], 'auto_pad', 'NOTSET') in ['SAME_UPPER', 'SAME_LOWER'] else 'VALID' "
    ],
    "dilation": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'dilations') if isinstance(self.attr_pick(node['Conv'], 'dilations'), int) else self.attr_pick(node['Conv'], 'dilations')[0]"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Conv:out0",
    "depthwise_conv2d_op:out0"
   ]
  ],
  "acu_lys_alias": [
   "depthwise_conv2d_op"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "depthwise_conv2d_op:in0"
   ],
   [
    "I_1:out0",
    "depthwise_conv2d_op:in1"
   ]
  ],
  "ruler_name": "r_depthwise_conv2d_op",
  "priority_tip": 1,
  "src_in_anchor": [
   [
    "I_0:out0",
    "Conv:in0"
   ],
   [
    "I_1:out0",
    "Conv:in1"
   ]
  ],
  "src_ops_alias": [
   "Conv"
  ],
  "blob_map": {
   "depthwise_conv2d_op": {}
  },
  "pre_condition": "self.attr_pick(node['Conv'], 'group', 1) == self.shape_pick(tensor['I_0:out0'])[1]",
  "src_out_tensor": [
   "Conv:out0"
  ],
  "param_map": {
   "depthwise_conv2d_op": {
    "pad_method": [
     "STRING",
     "CODE",
     "'auto' if self.attr_pick(node['Conv'], 'pads', None) == None else 'padding_const'"
    ],
    "dilation": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'dilations') if isinstance(self.attr_pick(node['Conv'], 'dilations'), int) else self.attr_pick(node['Conv'], 'dilations')[0]"
    ],
    "group_number": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'group', 1)"
    ],
    "ksize_w": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'kernel_shape')[1]"
    ],
    "pad": [
     "INTS",
     "CODE",
     "[p for p in self.array_layout(self.attr_pick(node['Conv'], 'pads', [ 0, 0, 0, 0]), [0, 2, 1, 3])]"
    ],
    "stride_h": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'strides', [1, 1])[0]"
    ],
    "stride_w": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'strides', [1, 1])[1]"
    ],
    "padding": [
     "STRING",
     "CODE",
     "'SAME' if self.attr_pick(node['Conv'], 'auto_pad', 'NOTSET') in ['SAME_UPPER', 'SAME_LOWER'] else 'VALID' "
    ],
    "ksize_h": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'kernel_shape')[0]"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   6,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Conv:out0",
    "convolution:out0"
   ]
  ],
  "acu_lys_alias": [
   "convolution"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "convolution:in0"
   ]
  ],
  "ruler_name": "r_conv_nchw_squeeze",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "Conv:in0"
   ]
  ],
  "src_ops_alias": [
   "Conv",
   "Constant",
   "Squeeze",
   "Constant_1"
  ],
  "blob_map": {
   "convolution": {
    "weight": [
     "CODE",
     "self.tensor_to_numpy(tensor['Constant:out0'])"
    ],
    "bias": [
     "CODE",
     "self.tensor_to_numpy(tensor['Squeeze:out0'])"
    ]
   }
  },
  "pre_condition": null,
  "src_out_tensor": [
   "Conv:out0"
  ],
  "param_map": {
   "convolution": {
    "pad_method": [
     "STRING",
     "CODE",
     "'auto' if self.attr_pick(node['Conv'], 'pads', None) == None else 'padding_const'"
    ],
    "pad": [
     "INTS",
     "CODE",
     "[p for p in self.array_layout(self.attr_pick(node['Conv'], 'pads', [ 0, 0, 0, 0]), [0, 2, 1, 3])]"
    ],
    "group_number": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'group', 1)"
    ],
    "ksize_w": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'kernel_shape')[1]"
    ],
    "bias": [
     "BOOL",
     "VALUE",
     true
    ],
    "stride_h": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'strides', [1, 1])[0]"
    ],
    "stride_w": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'strides', [1, 1])[1]"
    ],
    "weights": [
     "INT",
     "CODE",
     "self.shape_pick(tensor['Squeeze:out0'])[0]"
    ],
    "dilation": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'dilations') if isinstance(self.attr_pick(node['Conv'], 'dilations'), int) else self.attr_pick(node['Conv'], 'dilations')[0]"
    ],
    "padding": [
     "STRING",
     "CODE",
     "'SAME' if self.attr_pick(node['Conv'], 'auto_pad', 'NOTSET') in ['SAME_UPPER', 'SAME_LOWER'] else 'VALID' "
    ],
    "ksize_h": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'kernel_shape')[0]"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant:out0",
    "Conv:in1"
   ],
   [
    "Squeeze:out0",
    "Conv:in2"
   ],
   [
    "Constant_1:out0",
    "Squeeze:in0"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": null,
  "src_acu_out_tensor_map": [
   [
    "Conv:out0",
    "convolution:out0"
   ]
  ],
  "acu_lys_alias": [
   "convolution"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "convolution:in0"
   ]
  ],
  "ruler_name": "r_conv_no_bias",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Conv:in0"
   ]
  ],
  "src_ops_alias": [
   "Conv",
   "Constant_0"
  ],
  "blob_map": {
   "convolution": {
    "weight": [
     "CODE",
     "self.tensor_to_numpy(tensor['Constant_0:out0'])"
    ]
   }
  },
  "pre_condition": null,
  "src_out_tensor": [
   "Conv:out0"
  ],
  "param_map": {
   "convolution": {
    "pad_method": [
     "STRING",
     "CODE",
     "'auto' if self.attr_pick(node['Conv'], 'pads', None) == None else 'padding_const'"
    ],
    "pad": [
     "INTS",
     "CODE",
     "[p for p in self.array_layout(self.attr_pick(node['Conv'], 'pads', [ 0, 0, 0, 0]), [0, 2, 1, 3])]"
    ],
    "group_number": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'group', 1)"
    ],
    "ksize_w": [
     "INT",
     "CODE",
     "self.shape_pick(tensor['Constant_0:out0'])[3]"
    ],
    "bias": [
     "BOOL",
     "VALUE",
     false
    ],
    "stride_h": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'strides', [1, 1])[0]"
    ],
    "stride_w": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'strides', [1, 1])[1]"
    ],
    "weights": [
     "INT",
     "CODE",
     "self.shape_pick(tensor['Constant_0:out0'])[0]"
    ],
    "dilation": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'dilations') if isinstance(self.attr_pick(node['Conv'], 'dilations'), int) else self.attr_pick(node['Conv'], 'dilations')[0]"
    ],
    "padding": [
     "STRING",
     "CODE",
     "'SAME' if self.attr_pick(node['Conv'], 'auto_pad', 'NOTSET') in ['SAME_UPPER', 'SAME_LOWER'] else 'VALID' "
    ],
    "ksize_h": [
     "INT",
     "CODE",
     "self.shape_pick(tensor['Constant_0:out0'])[2]"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant_0:out0",
    "Conv:in1"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": null,
  "src_acu_out_tensor_map": [
   [
    "Conv:out0",
    "conv3d:out0"
   ]
  ],
  "acu_lys_alias": [
   "conv3d"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "conv3d:in0"
   ]
  ],
  "ruler_name": "r_conv3d_no_bias",
  "priority_tip": 1,
  "src_in_anchor": [
   [
    "I:out0",
    "Conv:in0"
   ]
  ],
  "src_ops_alias": [
   "Conv",
   "Constant_0"
  ],
  "blob_map": {
   "conv3d": {
    "weight": [
     "CODE",
     "self.tensor_to_numpy(tensor['Constant_0:out0'])"
    ]
   }
  },
  "pre_condition": "len(self.shape_pick(tensor['Constant_0:out0'])) == 5",
  "src_out_tensor": [
   "Conv:out0"
  ],
  "param_map": {
   "conv3d": {
    "pad_method": [
     "STRING",
     "CODE",
     "'auto' if self.attr_pick(node['Conv'], 'pads', None) == None else 'padding_const'"
    ],
    "ksize_h": [
     "INT",
     "CODE",
     "self.shape_pick(tensor['Constant_0:out0'])[3]"
    ],
    "group_number": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'group', 1)"
    ],
    "padding": [
     "STRING",
     "CODE",
     "'SAME' if self.attr_pick(node['Conv'], 'auto_pad', 'NOTSET') in ['SAME_UPPER', 'SAME_LOWER'] else 'VALID' "
    ],
    "dilation": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'dilations') if isinstance(self.attr_pick(node['Conv'], 'dilations'), int) else self.attr_pick(node['Conv'], 'dilations')[0]"
    ],
    "pad": [
     "INTS",
     "CODE",
     "[p for p in self.array_layout(self.attr_pick(node['Conv'], 'pads', [ 0, 0, 0, 0, 0, 0]), [0, 3, 1, 4, 2, 5])]"
    ],
    "stride_d": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'strides', [1, 1, 1])[0]"
    ],
    "bias": [
     "BOOL",
     "VALUE",
     false
    ],
    "ksize_w": [
     "INT",
     "CODE",
     "self.shape_pick(tensor['Constant_0:out0'])[4]"
    ],
    "stride_h": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'strides', [1, 1, 1])[1]"
    ],
    "stride_w": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'strides', [1, 1, 1])[2]"
    ],
    "weights": [
     "INT",
     "CODE",
     "self.shape_pick(tensor['Constant_0:out0'])[0]"
    ],
    "ksize_d": [
     "INT",
     "CODE",
     "self.shape_pick(tensor['Constant_0:out0'])[2]"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant_0:out0",
    "Conv:in1"
   ]
  ],
  "acu_inter_flow": [
   [
    "Constant_0:out0",
    "conv3d:in1"
   ]
  ]
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": null,
  "src_acu_out_tensor_map": [
   [
    "Add:out0",
    "convolution:out0"
   ]
  ],
  "acu_lys_alias": [
   "convolution"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "convolution:in0"
   ]
  ],
  "ruler_name": "r_conv_add",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Conv:in0"
   ]
  ],
  "src_ops_alias": [
   "Conv",
   "Add",
   "Constant_0",
   "Constant_1"
  ],
  "blob_map": {
   "convolution": {
    "weight": [
     "CODE",
     "self.tensor_to_numpy(tensor['Constant_0:out0'])"
    ],
    "bias": [
     "CODE",
     "self.conv_bias(tensor['Constant_0:out0'], tensor['Constant_1:out0'])"
    ]
   }
  },
  "pre_condition": "self.is_single_refs(tensor['Conv:out0']) == True",
  "src_out_tensor": [
   "Add:out0"
  ],
  "param_map": {
   "convolution": {
    "pad_method": [
     "STRING",
     "CODE",
     "'auto' if self.attr_pick(node['Conv'], 'pads', None) == None else 'padding_const'"
    ],
    "pad": [
     "INTS",
     "CODE",
     "[p for p in self.array_layout(self.attr_pick(node['Conv'], 'pads', [ 0, 0, 0, 0]), [0, 2, 1, 3])]"
    ],
    "group_number": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'group', 1)"
    ],
    "ksize_w": [
     "INT",
     "CODE",
     "self.shape_pick(tensor['Constant_0:out0'])[3]"
    ],
    "bias": [
     "BOOL",
     "VALUE",
     true
    ],
    "stride_h": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'strides', [1, 1])[0]"
    ],
    "stride_w": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'strides', [1, 1])[1]"
    ],
    "weights": [
     "INT",
     "CODE",
     "self.shape_pick(tensor['Constant_0:out0'])[0]"
    ],
    "dilation": [
     "INT",
     "CODE",
     "self.attr_pick(node['Conv'], 'dilations') if isinstance(self.attr_pick(node['Conv'], 'dilations'), int) else self.attr_pick(node['Conv'], 'dilations')[0]"
    ],
    "padding": [
     "STRING",
     "CODE",
     "'SAME' if self.attr_pick(node['Conv'], 'auto_pad', 'NOTSET') in ['SAME_UPPER', 'SAME_LOWER'] else 'VALID' "
    ],
    "ksize_h": [
     "INT",
     "CODE",
     "self.shape_pick(tensor['Constant_0:out0'])[2]"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Conv:out0",
    "Add:in0"
   ],
   [
    "Constant_0:out0",
    "Conv:in1"
   ],
   [
    "Constant_1:out0",
    "Add:in1"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": null,
  "src_acu_out_tensor_map": [
   [
    "ConvTranspose:out0",
    "deconvolution:out0"
   ]
  ],
  "acu_lys_alias": [
   "deconvolution"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "deconvolution:in0"
   ]
  ],
  "ruler_name": "r_dconvolution",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "ConvTranspose:in0"
   ]
  ],
  "src_ops_alias": [
   "ConvTranspose",
   "Constant_0",
   "Constant_1"
  ],
  "blob_map": {
   "deconvolution": {
    "weight": [
     "CODE",
     "self.tensor_to_numpy(tensor['Constant_0:out0'])"
    ],
    "bias": [
     "CODE",
     "self.tensor_to_numpy(tensor['Constant_1:out0'])"
    ]
   }
  },
  "pre_condition": "len(self.shape_pick(tensor['Constant_0:out0'])) == 4",
  "src_out_tensor": [
   "ConvTranspose:out0"
  ],
  "param_map": {
   "deconvolution": {
    "output_shape": [
     "INTS",
     "CODE",
     "self.attr_pick(node['ConvTranspose'], '_out_shape')[0]"
    ],
    "pad_method": [
     "STRING",
     "CODE",
     "'padding_const' if self.attr_pick(node['ConvTranspose'], 'auto_pad', 'NOTSET') == 'NOTSET' else 'auto' "
    ],
    "ksize_h": [
     "INT",
     "PYFUNC",
     [
      "__rule_func_additional_args = {\"dim\": \"height\"}",
      "def r_dconv_get_kernel_shape(self, node, tensor, dim):",
      "    kernel_shape = self.attr_pick(node['ConvTranspose'], 'kernel_shape')",
      "    if not kernel_shape:",
      "        kernel = self.tensor_to_numpy(tensor['Constant_0:out0'])",
      "        kernel_shape = kernel.shape",
      "        ksize_h = kernel_shape[2]",
      "        ksize_w = kernel_shape[3]",
      "    else:",
      "        ksize_h = kernel_shape[0]",
      "        ksize_w = kernel_shape[1]",
      "    if dim == 'height':",
      "        return ksize_h",
      "    if dim == 'width':",
      "        return ksize_w",
      ""
     ]
    ],
    "group_number": [
     "INT",
     "CODE",
     "self.attr_pick(node['ConvTranspose'], 'group', 1)"
    ],
    "padding": [
     "STRING",
     "CODE",
     "'SAME' if self.attr_pick(node['ConvTranspose'], 'auto_pad', 'NOTSET') in ['SAME_UPPER', 'SAME_LOWER'] else 'VALID' "
    ],
    "pad_w": [
     "INT",
     "CODE",
     "self.attr_pick(node['ConvTranspose'], 'pads', [0, 0, 0, 0])[1]"
    ],
    "pad": [
     "INTS",
     "CODE",
     "self.array_layout(self.attr_pick(node['ConvTranspose'], 'pads', [0, 0, 0, 0]), [0, 2, 1, 3])"
    ],
    "bias": [
     "BOOL",
     "VALUE",
     true
    ],
    "ksize_w": [
     "INT",
     "PYFUNC",
     [
      "__rule_func_additional_args = {\"dim\": \"width\"}",
      "def r_dconv_get_kernel_shape(self, node, tensor, dim):",
      "    kernel_shape = self.attr_pick(node['ConvTranspose'], 'kernel_shape')",
      "    if not kernel_shape:",
      "        kernel = self.tensor_to_numpy(tensor['Constant_0:out0'])",
      "        kernel_shape = kernel.shape",
      "        ksize_h = kernel_shape[2]",
      "        ksize_w = kernel_shape[3]",
      "    else:",
      "        ksize_h = kernel_shape[0]",
      "        ksize_w = kernel_shape[1]",
      "    if dim == 'height':",
      "        return ksize_h",
      "    if dim == 'width':",
      "        return ksize_w",
      ""
     ]
    ],
    "stride_h": [
     "INT",
     "CODE",
     "self.attr_pick(node['ConvTranspose'], 'strides', [1, 1])[0]"
    ],
    "stride_w": [
     "INT",
     "CODE",
     "self.attr_pick(node['ConvTranspose'], 'strides', [1, 1])[1]"
    ],
    "weights": [
     "INT",
     "PYFUNC",
     [
      "__rule_func_additional_args = {\"weight\": \"Constant_0:out0\"}",
      "def r_get_deconv_weights(self, node, tensor, weight):",
      "    in_channel = self.shape_pick(tensor[weight])[1]",
      "    group = self.attr_pick(node['ConvTranspose'], 'group', 1)",
      "    weights = in_channel * group",
      "    return weights",
      ""
     ]
    ],
    "pad_h": [
     "INT",
     "CODE",
     "self.attr_pick(node['ConvTranspose'], 'pads', [0, 0, 0, 0])[0]"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant_0:out0",
    "ConvTranspose:in1"
   ],
   [
    "Constant_1:out0",
    "ConvTranspose:in2"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": null,
  "src_acu_out_tensor_map": [
   [
    "ConvTranspose:out0",
    "deconvolution:out0"
   ]
  ],
  "acu_lys_alias": [
   "deconvolution"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "deconvolution:in0"
   ]
  ],
  "ruler_name": "r_dconvolution_no_bias",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "ConvTranspose:in0"
   ]
  ],
  "src_ops_alias": [
   "ConvTranspose",
   "Constant_0"
  ],
  "blob_map": {
   "deconvolution": {
    "weight": [
     "CODE",
     "self.tensor_to_numpy(tensor['Constant_0:out0'])"
    ]
   }
  },
  "pre_condition": "len(self.shape_pick(tensor['Constant_0:out0'])) == 4",
  "src_out_tensor": [
   "ConvTranspose:out0"
  ],
  "param_map": {
   "deconvolution": {
    "output_shape": [
     "INTS",
     "CODE",
     "self.attr_pick(node['ConvTranspose'], '_out_shape')[0]"
    ],
    "pad_method": [
     "STRING",
     "CODE",
     "'padding_const' if self.attr_pick(node['ConvTranspose'], 'auto_pad', 'NOTSET') == 'NOTSET' else 'auto' "
    ],
    "ksize_h": [
     "INT",
     "PYFUNC",
     [
      "__rule_func_additional_args = {\"dim\": \"height\"}",
      "def r_dconv_get_kernel_shape(self, node, tensor, dim):",
      "    kernel_shape = self.attr_pick(node['ConvTranspose'], 'kernel_shape')",
      "    if not kernel_shape:",
      "        kernel = self.tensor_to_numpy(tensor['Constant_0:out0'])",
      "        kernel_shape = kernel.shape",
      "        ksize_h = kernel_shape[2]",
      "        ksize_w = kernel_shape[3]",
      "    else:",
      "        ksize_h = kernel_shape[0]",
      "        ksize_w = kernel_shape[1]",
      "    if dim == 'height':",
      "        return ksize_h",
      "    if dim == 'width':",
      "        return ksize_w",
      ""
     ]
    ],
    "group_number": [
     "INT",
     "CODE",
     "self.attr_pick(node['ConvTranspose'], 'group', 1)"
    ],
    "padding": [
     "STRING",
     "CODE",
     "'SAME' if self.attr_pick(node['ConvTranspose'], 'auto_pad', 'NOTSET') in ['SAME_UPPER', 'SAME_LOWER'] else 'VALID' "
    ],
    "pad_w": [
     "INT",
     "CODE",
     "self.attr_pick(node['ConvTranspose'], 'pads', [0, 0, 0, 0])[1]"
    ],
    "pad": [
     "INTS",
     "CODE",
     "self.array_layout(self.attr_pick(node['ConvTranspose'], 'pads', [0, 0, 0, 0]), [0, 2, 1, 3])"
    ],
    "bias": [
     "BOOL",
     "VALUE",
     false
    ],
    "ksize_w": [
     "INT",
     "PYFUNC",
     [
      "__rule_func_additional_args = {\"dim\": \"width\"}",
      "def r_dconv_get_kernel_shape(self, node, tensor, dim):",
      "    kernel_shape = self.attr_pick(node['ConvTranspose'], 'kernel_shape')",
      "    if not kernel_shape:",
      "        kernel = self.tensor_to_numpy(tensor['Constant_0:out0'])",
      "        kernel_shape = kernel.shape",
      "        ksize_h = kernel_shape[2]",
      "        ksize_w = kernel_shape[3]",
      "    else:",
      "        ksize_h = kernel_shape[0]",
      "        ksize_w = kernel_shape[1]",
      "    if dim == 'height':",
      "        return ksize_h",
      "    if dim == 'width':",
      "        return ksize_w",
      ""
     ]
    ],
    "stride_h": [
     "INT",
     "CODE",
     "self.attr_pick(node['ConvTranspose'], 'strides', [1, 1])[0]"
    ],
    "stride_w": [
     "INT",
     "CODE",
     "self.attr_pick(node['ConvTranspose'], 'strides', [1, 1])[1]"
    ],
    "weights": [
     "INT",
     "PYFUNC",
     [
      "__rule_func_additional_args = {\"weight\": \"Constant_0:out0\"}",
      "def r_get_deconv_weights(self, node, tensor, weight):",
      "    in_channel = self.shape_pick(tensor[weight])[1]",
      "    group = self.attr_pick(node['ConvTranspose'], 'group', 1)",
      "    weights = in_channel * group",
      "    return weights",
      ""
     ]
    ],
    "pad_h": [
     "INT",
     "CODE",
     "self.attr_pick(node['ConvTranspose'], 'pads', [0, 0, 0, 0])[0]"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant_0:out0",
    "ConvTranspose:in1"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Add:out0",
    "deconvolution:out0"
   ]
  ],
  "acu_lys_alias": [
   "deconvolution"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "deconvolution:in0"
   ]
  ],
  "ruler_name": "r_deconvolution_with_add",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "ConvTranspose:in0"
   ]
  ],
  "src_ops_alias": [
   "Add",
   "ConvTranspose",
   "Constant",
   "Constant_1"
  ],
  "blob_map": {
   "deconvolution": {
    "weight": [
     "CODE",
     "self.tensor_to_numpy(tensor['Constant:out0'])"
    ],
    "bias": [
     "CODE",
     "self.tensor_to_numpy(tensor['Constant_1:out0']).flatten()"
    ]
   }
  },
  "pre_condition": [
   "__rule_func_additional_args = {\"bias_tensor\": \"Constant_1:out0\"}",
   "def r_bias_var_check(self, node, tensor, bias_tensor):",
   "    data = self.tensor_to_numpy(tensor[bias_tensor])",
   "    if data.ndim >= 2 and data.shape[1] == data.size:",
   "        return True",
   "    return False",
   ""
  ],
  "src_out_tensor": [
   "Add:out0"
  ],
  "param_map": {
   "deconvolution": {
    "output_shape": [
     "INTS",
     "CODE",
     "self.attr_pick(node['ConvTranspose'], '_out_shape')[0]"
    ],
    "pad_method": [
     "STRING",
     "CODE",
     "'padding_const' if self.attr_pick(node['ConvTranspose'], 'auto_pad', 'NOTSET') == 'NOTSET' else 'auto' "
    ],
    "ksize_h": [
     "INT",
     "PYFUNC",
     [
      "__rule_func_additional_args = {\"dim\": \"height\"}",
      "def r_dconv_get_kernel_shape(self, node, tensor, dim):",
      "    kernel_shape = self.attr_pick(node['ConvTranspose'], 'kernel_shape')",
      "    if not kernel_shape:",
      "        kernel = self.tensor_to_numpy(tensor['Constant_0:out0'])",
      "        kernel_shape = kernel.shape",
      "        ksize_h = kernel_shape[2]",
      "        ksize_w = kernel_shape[3]",
      "    else:",
      "        ksize_h = kernel_shape[0]",
      "        ksize_w = kernel_shape[1]",
      "    if dim == 'height':",
      "        return ksize_h",
      "    if dim == 'width':",
      "        return ksize_w",
      ""
     ]
    ],
    "group_number": [
     "INT",
     "CODE",
     "self.attr_pick(node['ConvTranspose'], 'group', 1)"
    ],
    "padding": [
     "STRING",
     "CODE",
     "'SAME' if self.attr_pick(node['ConvTranspose'], 'auto_pad', 'NOTSET') in ['SAME_UPPER', 'SAME_LOWER'] else 'VALID' "
    ],
    "pad_w": [
     "INT",
     "CODE",
     "self.attr_pick(node['ConvTranspose'], 'pads', [0, 0, 0, 0])[1]"
    ],
    "pad": [
     "INTS",
     "CODE",
     "self.array_layout(self.attr_pick(node['ConvTranspose'], 'pads', [0, 0, 0, 0]), [0, 2, 1, 3])"
    ],
    "bias": [
     "BOOL",
     "VALUE",
     true
    ],
    "ksize_w": [
     "INT",
     "PYFUNC",
     [
      "__rule_func_additional_args = {\"dim\": \"width\"}",
      "def r_dconv_get_kernel_shape(self, node, tensor, dim):",
      "    kernel_shape = self.attr_pick(node['ConvTranspose'], 'kernel_shape')",
      "    if not kernel_shape:",
      "        kernel = self.tensor_to_numpy(tensor['Constant_0:out0'])",
      "        kernel_shape = kernel.shape",
      "        ksize_h = kernel_shape[2]",
      "        ksize_w = kernel_shape[3]",
      "    else:",
      "        ksize_h = kernel_shape[0]",
      "        ksize_w = kernel_shape[1]",
      "    if dim == 'height':",
      "        return ksize_h",
      "    if dim == 'width':",
      "        return ksize_w",
      ""
     ]
    ],
    "stride_h": [
     "INT",
     "CODE",
     "self.attr_pick(node['ConvTranspose'], 'strides', [1, 1])[0]"
    ],
    "stride_w": [
     "INT",
     "CODE",
     "self.attr_pick(node['ConvTranspose'], 'strides', [1, 1])[1]"
    ],
    "weights": [
     "INT",
     "PYFUNC",
     [
      "__rule_func_additional_args = {\"weight\": \"Constant:out0\"}",
      "def r_get_deconv_weights(self, node, tensor, weight):",
      "    in_channel = self.shape_pick(tensor[weight])[1]",
      "    group = self.attr_pick(node['ConvTranspose'], 'group', 1)",
      "    weights = in_channel * group",
      "    return weights",
      ""
     ]
    ],
    "pad_h": [
     "INT",
     "CODE",
     "self.attr_pick(node['ConvTranspose'], 'pads', [0, 0, 0, 0])[0]"
    ]
   }
  },
  "src_inter_flow": [
   [
    "ConvTranspose:out0",
    "Add:in0"
   ],
   [
    "Constant_1:out0",
    "Add:in1"
   ],
   [
    "Constant:out0",
    "ConvTranspose:in1"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_acu_out_tensor_map": [
   [
    "ConvTranspose:out0",
    "deconvolution1d:out0"
   ]
  ],
  "acu_lys_alias": [
   "deconvolution1d"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "deconvolution1d:in0"
   ]
  ],
  "ruler_name": "r_dconv1d_no_bias",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "ConvTranspose:in0"
   ]
  ],
  "src_ops_alias": [
   "ConvTranspose",
   "Constant_0"
  ],
  "blob_map": {
   "deconvolution1d": {
    "weight": [
     "CODE",
     "self.tensor_to_numpy(tensor['Constant_0:out0'])"
    ]
   }
  },
  "pre_condition": "len(self.shape_pick(tensor['Constant_0:out0'])) == 3",
  "src_out_tensor": [
   "ConvTranspose:out0"
  ],
  "param_map": {
   "deconvolution1d": {
    "pad_method": [
     "STRING",
     "CODE",
     "'padding_const' if self.attr_pick(node['ConvTranspose'], 'auto_pad', 'NOTSET') == 'NOTSET' else 'auto' "
    ],
    "stride": [
     "INT",
     "CODE",
     "self.attr_pick(node['ConvTranspose'], 'strides')[0]"
    ],
    "output_padding": [
     "INT",
     "CODE",
     "self.attr_pick(node['ConvTranspose'], 'output_padding', 0) if isinstance(self.attr_pick(node['ConvTranspose'], 'output_padding', 0), int)else self.attr_pick(node['ConvTranspose'], 'output_padding', 0)[0]"
    ],
    "group_number": [
     "INT",
     "CODE",
     "self.attr_pick(node['ConvTranspose'], 'group', 1)"
    ],
    "ksize": [
     "INT",
     "CODE",
     "self.shape_pick(tensor['Constant_0:out0'])[2]"
    ],
    "pad": [
     "INTS",
     "CODE",
     "self.attr_pick(node['ConvTranspose'], 'pads')"
    ],
    "bias": [
     "BOOL",
     "VALUE",
     false
    ],
    "weights": [
     "INT",
     "PYFUNC",
     [
      "__rule_func_additional_args = {\"weight\": \"Constant_0:out0\"}",
      "def r_get_deconv_weights(self, node, tensor, weight):",
      "    in_channel = self.shape_pick(tensor[weight])[1]",
      "    group = self.attr_pick(node['ConvTranspose'], 'group', 1)",
      "    weights = in_channel * group",
      "    return weights",
      ""
     ]
    ],
    "padding": [
     "STRING",
     "CODE",
     "'SAME' if self.attr_pick(node['ConvTranspose'], 'auto_pad', 'NOTSET') in ['SAME_UPPER', 'SAME_LOWER'] else 'VALID' "
    ],
    "output_shape": [
     "INTS",
     "CODE",
     "self.attr_pick(node['ConvTranspose'], '_out_shape')[0]"
    ],
    "dilation": [
     "INT",
     "CODE",
     "self.attr_pick(node['ConvTranspose'], 'dilations', [1])[0]"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant_0:out0",
    "ConvTranspose:in1"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "ConvTranspose:out0",
    "deconvolution1d:out0"
   ]
  ],
  "acu_lys_alias": [
   "deconvolution1d"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "deconvolution1d:in0"
   ]
  ],
  "ruler_name": "r_deconv1d",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "ConvTranspose:in0"
   ]
  ],
  "src_ops_alias": [
   "ConvTranspose",
   "Constant",
   "Constant_1"
  ],
  "blob_map": {
   "deconvolution1d": {
    "weight": [
     "CODE",
     "self.tensor_to_numpy(tensor['Constant:out0'])"
    ],
    "bias": [
     "CODE",
     "self.tensor_to_numpy(tensor['Constant_1:out0'])"
    ]
   }
  },
  "pre_condition": "len(self.shape_pick(tensor['Constant:out0'])) == 3",
  "src_out_tensor": [
   "ConvTranspose:out0"
  ],
  "param_map": {
   "deconvolution1d": {
    "pad_method": [
     "STRING",
     "CODE",
     "'padding_const' if self.attr_pick(node['ConvTranspose'], 'auto_pad', 'NOTSET') == 'NOTSET' else 'auto' "
    ],
    "stride": [
     "INT",
     "CODE",
     "self.attr_pick(node['ConvTranspose'], 'strides')[0]"
    ],
    "output_padding": [
     "INT",
     "CODE",
     "self.attr_pick(node['ConvTranspose'], 'output_padding', 0) if isinstance(self.attr_pick(node['ConvTranspose'], 'output_padding', 0), int)else self.attr_pick(node['ConvTranspose'], 'output_padding', 0)[0]"
    ],
    "group_number": [
     "INT",
     "CODE",
     "self.attr_pick(node['ConvTranspose'], 'group', 1)"
    ],
    "ksize": [
     "INT",
     "CODE",
     "self.shape_pick(tensor['Constant:out0'])[2]"
    ],
    "pad": [
     "INTS",
     "CODE",
     "self.attr_pick(node['ConvTranspose'], 'pads')"
    ],
    "bias": [
     "BOOL",
     "VALUE",
     true
    ],
    "weights": [
     "INT",
     "PYFUNC",
     [
      "__rule_func_additional_args = {\"weight\": \"Constant:out0\"}",
      "def r_get_deconv_weights(self, node, tensor, weight):",
      "    in_channel = self.shape_pick(tensor[weight])[1]",
      "    group = self.attr_pick(node['ConvTranspose'], 'group', 1)",
      "    weights = in_channel * group",
      "    return weights",
      ""
     ]
    ],
    "padding": [
     "STRING",
     "CODE",
     "'SAME' if self.attr_pick(node['ConvTranspose'], 'auto_pad', 'NOTSET') in ['SAME_UPPER', 'SAME_LOWER'] else 'VALID' "
    ],
    "output_shape": [
     "INTS",
     "CODE",
     "self.attr_pick(node['ConvTranspose'], '_out_shape')[0]"
    ],
    "dilation": [
     "INT",
     "CODE",
     "self.attr_pick(node['ConvTranspose'], 'dilations', [1])[0]"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant:out0",
    "ConvTranspose:in1"
   ],
   [
    "Constant_1:out0",
    "ConvTranspose:in2"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   6,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "BatchNormalization:out0",
    "batchnormalize:out0"
   ]
  ],
  "acu_lys_alias": [
   "batchnormalize"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "batchnormalize:in0"
   ]
  ],
  "ruler_name": "r_bn_v6",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "BatchNormalization:in0"
   ]
  ],
  "src_ops_alias": [
   "BatchNormalization",
   "Constant_0",
   "Constant_1",
   "Constant_2",
   "Constant_3"
  ],
  "blob_map": {
   "batchnormalize": {
    "mean": [
     "CODE",
     "self.tensor_to_numpy(tensor['Constant_3:out0'])"
    ],
    "gamma": [
     "CODE",
     "self.tensor_to_numpy(tensor['Constant_0:out0'])"
    ],
    "beta": [
     "CODE",
     "self.tensor_to_numpy(tensor['Constant_1:out0'])"
    ],
    "variance": [
     "CODE",
     "self.tensor_to_numpy(tensor['Constant_2:out0'])"
    ]
   }
  },
  "pre_condition": null,
  "src_out_tensor": [
   "BatchNormalization:out0"
  ],
  "param_map": {
   "batchnormalize": {
    "eps": [
     "FLOAT",
     "CODE",
     "self.attr_pick(node['BatchNormalization'], 'epsilon', 1e-5)"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant_2:out0",
    "BatchNormalization:in4"
   ],
   [
    "Constant_1:out0",
    "BatchNormalization:in2"
   ],
   [
    "Constant_3:out0",
    "BatchNormalization:in3"
   ],
   [
    "Constant_0:out0",
    "BatchNormalization:in1"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   5
  ],
  "src_acu_out_tensor_map": [
   [
    "BatchNormalization:out0",
    "batchnormalize:out0"
   ]
  ],
  "acu_lys_alias": [
   "batchnormalize"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "batchnormalize:in0"
   ]
  ],
  "ruler_name": "r_bn_v5",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "BatchNormalization:in0"
   ]
  ],
  "src_ops_alias": [
   "BatchNormalization",
   "Constant_0",
   "Constant_1",
   "Constant_2",
   "Constant_3"
  ],
  "blob_map": {
   "batchnormalize": {
    "mean": [
     "CODE",
     "None if self.attr_pick(node['BatchNormalization'], 'consumed_inputs')[4] == 0 else self.tensor_to_numpy(tensor['Constant_3:out0'])"
    ],
    "gamma": [
     "CODE",
     "None if self.attr_pick(node['BatchNormalization'], 'consumed_inputs')[1] == 0 else self.tensor_to_numpy(tensor['Constant_0:out0'])"
    ],
    "beta": [
     "CODE",
     "None if self.attr_pick(node['BatchNormalization'], 'consumed_inputs')[2] == 0 else self.tensor_to_numpy(tensor['Constant_1:out0'])"
    ],
    "variance": [
     "CODE",
     "None if self.attr_pick(node['BatchNormalization'], 'consumed_inputs')[3] == 0 else self.tensor_to_numpy(tensor['Constant_2:out0'])"
    ]
   }
  },
  "pre_condition": null,
  "src_out_tensor": [
   "BatchNormalization:out0"
  ],
  "param_map": {
   "batchnormalize": {
    "eps": [
     "FLOAT",
     "CODE",
     "self.attr_pick(node['BatchNormalization'], 'epsilon', 1e-5)"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant_2:out0",
    "BatchNormalization:in4"
   ],
   [
    "Constant_1:out0",
    "BatchNormalization:in2"
   ],
   [
    "Constant_3:out0",
    "BatchNormalization:in3"
   ],
   [
    "Constant_0:out0",
    "BatchNormalization:in1"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   5
  ],
  "src_acu_out_tensor_map": [
   [
    "Add:out0",
    "batchnormalize:out0"
   ]
  ],
  "acu_lys_alias": [
   "batchnormalize"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "batchnormalize:in0"
   ]
  ],
  "ruler_name": "r_bn_mul_add_v5",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "BatchNormalization:in0"
   ]
  ],
  "src_ops_alias": [
   "BatchNormalization",
   "Constant_0",
   "Constant_1",
   "Constant_2",
   "Constant_3",
   "Mul",
   "Constant_4",
   "Add",
   "Constant_5"
  ],
  "blob_map": {
   "batchnormalize": {
    "mean": [
     "CODE",
     "None if self.attr_pick(node['BatchNormalization'], 'consumed_inputs')[4] == 0 else self.tensor_to_numpy(tensor['Constant_3:out0'])"
    ],
    "gamma": [
     "CODE",
     "self.tensor_to_numpy(tensor['Constant_4:out0']) if self.attr_pick(node['BatchNormalization'], 'consumed_inputs')[1] == 0 else self.tensor_to_numpy(tensor['Constant_0:out0']) * self.tensor_to_numpy(tensor['Constant_4:out0'])"
    ],
    "beta": [
     "CODE",
     "self.tensor_to_numpy(tensor['Constant_5:out0']) if self.attr_pick(node['BatchNormalization'], 'consumed_inputs')[1] == 0 else self.tensor_to_numpy(tensor['Constant_1:out0']) * self.tensor_to_numpy(tensor['Constant_4:out0']) + self.tensor_to_numpy(tensor['Constant_5:out0'])"
    ],
    "variance": [
     "CODE",
     "None if self.attr_pick(node['BatchNormalization'], 'consumed_inputs')[3] == 0 else self.tensor_to_numpy(tensor['Constant_2:out0'])"
    ]
   }
  },
  "pre_condition": null,
  "src_out_tensor": [
   "Add:out0"
  ],
  "param_map": {
   "batchnormalize": {
    "eps": [
     "FLOAT",
     "CODE",
     "self.attr_pick(node['BatchNormalization'], 'epsilon', 1e-5)"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant_2:out0",
    "BatchNormalization:in4"
   ],
   [
    "Constant_1:out0",
    "BatchNormalization:in2"
   ],
   [
    "Constant_3:out0",
    "BatchNormalization:in3"
   ],
   [
    "Constant_0:out0",
    "BatchNormalization:in1"
   ],
   [
    "BatchNormalization:out0",
    "Mul:in0"
   ],
   [
    "Constant_4:out0",
    "Mul:in1"
   ],
   [
    "Mul:out0",
    "Add:in0"
   ],
   [
    "Constant_5:out0",
    "Add:in1"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   6,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Add:out0",
    "batchnormalize:out0"
   ]
  ],
  "acu_lys_alias": [
   "batchnormalize"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "batchnormalize:in0"
   ]
  ],
  "ruler_name": "r_bn_mul_add_v6",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "BatchNormalization:in0"
   ]
  ],
  "src_ops_alias": [
   "BatchNormalization",
   "Constant_0",
   "Constant_1",
   "Constant_2",
   "Constant_3",
   "Mul",
   "Constant_4",
   "Add",
   "Constant_5"
  ],
  "blob_map": {
   "batchnormalize": {
    "mean": [
     "CODE",
     " self.tensor_to_numpy(tensor['Constant_3:out0'])"
    ],
    "gamma": [
     "CODE",
     " self.tensor_to_numpy(tensor['Constant_0:out0']) * self.tensor_to_numpy(tensor['Constant_4:out0'])"
    ],
    "beta": [
     "CODE",
     "self.tensor_to_numpy(tensor['Constant_1:out0']) * self.tensor_to_numpy(tensor['Constant_4:out0']) + self.tensor_to_numpy(tensor['Constant_5:out0'])"
    ],
    "variance": [
     "CODE",
     " self.tensor_to_numpy(tensor['Constant_2:out0'])"
    ]
   }
  },
  "pre_condition": null,
  "src_out_tensor": [
   "Add:out0"
  ],
  "param_map": {
   "batchnormalize": {
    "eps": [
     "FLOAT",
     "CODE",
     "self.attr_pick(node['BatchNormalization'], 'epsilon', 1e-5)"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant_2:out0",
    "BatchNormalization:in4"
   ],
   [
    "Constant_1:out0",
    "BatchNormalization:in2"
   ],
   [
    "Constant_3:out0",
    "BatchNormalization:in3"
   ],
   [
    "Constant_0:out0",
    "BatchNormalization:in1"
   ],
   [
    "BatchNormalization:out0",
    "Mul:in0"
   ],
   [
    "Constant_4:out0",
    "Mul:in1"
   ],
   [
    "Mul:out0",
    "Add:in0"
   ],
   [
    "Constant_5:out0",
    "Add:in1"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "MaxPool:out0",
    "pooling:out0"
   ]
  ],
  "acu_lys_alias": [
   "pooling"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "pooling:in0"
   ]
  ],
  "ruler_name": "r_maxpool",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "MaxPool:in0"
   ]
  ],
  "src_ops_alias": [
   "MaxPool"
  ],
  "blob_map": {},
  "pre_condition": "len(self.attr_pick(node['MaxPool'], 'kernel_shape')) == 2",
  "src_out_tensor": [
   "MaxPool:out0"
  ],
  "param_map": {
   "pooling": {
    "pad_method": [
     "STRING",
     "CODE",
     "'auto' if self.attr_pick(node['MaxPool'], 'pads', None) == None else 'padding_const'"
    ],
    "pad": [
     "INTS",
     "CODE",
     "[p for p in self.array_layout(self.attr_pick(node['MaxPool'], 'pads', [ 0, 0, 0, 0]), [0, 2, 1, 3])]"
    ],
    "ksize_h": [
     "INT",
     "CODE",
     "self.attr_pick(node['MaxPool'], 'kernel_shape')[0]"
    ],
    "pad_w": [
     "INT",
     "CODE",
     "self.attr_pick(node['MaxPool'], 'pads', [0, 0, 0, 0])[1]"
    ],
    "ksize_w": [
     "INT",
     "CODE",
     "self.attr_pick(node['MaxPool'], 'kernel_shape')[1]"
    ],
    "type": [
     "STRING",
     "VALUE",
     "MAX"
    ],
    "stride_h": [
     "INT",
     "CODE",
     "self.attr_pick(node['MaxPool'], 'strides', [1, 1])[0]"
    ],
    "stride_w": [
     "INT",
     "CODE",
     "self.attr_pick(node['MaxPool'], 'strides', [1, 1])[1]"
    ],
    "round_type": [
     "STRING",
     "CODE",
     "'ceil' if self.attr_pick(node['MaxPool'], 'ceil_mode') == 1 else 'floor'"
    ],
    "padding": [
     "STRING",
     "CODE",
     "'SAME' if self.attr_pick(node['MaxPool'], 'auto_pad', 'NOTSET') in ['SAME_UPPER', 'SAME_LOWER'] else 'VALID'"
    ],
    "pad_h": [
     "INT",
     "CODE",
     "self.attr_pick(node['MaxPool'], 'pads', [0, 0, 0, 0])[0]"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "MaxPool:out0",
    "pool3d:out0"
   ]
  ],
  "acu_lys_alias": [
   "pool3d"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "pool3d:in0"
   ]
  ],
  "ruler_name": "r_maxpool3d",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "MaxPool:in0"
   ]
  ],
  "src_ops_alias": [
   "MaxPool"
  ],
  "blob_map": {
   "pool3d": {}
  },
  "pre_condition": "len(self.attr_pick(node['MaxPool'], 'kernel_shape')) == 3",
  "src_out_tensor": [
   "MaxPool:out0"
  ],
  "param_map": {
   "pool3d": {
    "pad_method": [
     "STRING",
     "CODE",
     "'auto' if self.attr_pick(node['MaxPool'], 'pads', None) == None else 'padding_const'"
    ],
    "stride_d": [
     "INT",
     "CODE",
     "self.attr_pick(node['MaxPool'], 'strides', [1, 1, 1])[2]"
    ],
    "pad": [
     "INTS",
     "CODE",
     "[p for p in self.array_layout(self.attr_pick(node['MaxPool'], 'pads', [ 0, 0, 0, 0, 0, 0]), [0, 2, 4, 1, 3, 5])]"
    ],
    "ksize_h": [
     "INT",
     "CODE",
     "self.attr_pick(node['MaxPool'], 'kernel_shape')[0]"
    ],
    "ksize_w": [
     "INT",
     "CODE",
     "self.attr_pick(node['MaxPool'], 'kernel_shape')[1]"
    ],
    "type": [
     "STRING",
     "VALUE",
     "MAX"
    ],
    "stride_h": [
     "INT",
     "CODE",
     "self.attr_pick(node['MaxPool'], 'strides', [1, 1, 1])[0]"
    ],
    "stride_w": [
     "INT",
     "CODE",
     "self.attr_pick(node['MaxPool'], 'strides', [1, 1, 1])[1]"
    ],
    "round_type": [
     "STRING",
     "CODE",
     "'ceil' if self.attr_pick(node['MaxPool'], 'ceil_mode') == 1 else 'floor'"
    ],
    "padding": [
     "STRING",
     "CODE",
     "'SAME' if self.attr_pick(node['MaxPool'], 'auto_pad', 'NOTSET') in ['SAME_UPPER', 'SAME_LOWER'] else 'VALID'"
    ],
    "ksize_d": [
     "INT",
     "CODE",
     "self.attr_pick(node['MaxPool'], 'kernel_shape')[2]"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "AveragePool:out0",
    "pooling:out0"
   ]
  ],
  "acu_lys_alias": [
   "pooling"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "pooling:in0"
   ]
  ],
  "ruler_name": "r_avgpool",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "AveragePool:in0"
   ]
  ],
  "src_ops_alias": [
   "AveragePool"
  ],
  "blob_map": {},
  "pre_condition": "len(self.attr_pick(node['AveragePool'], 'kernel_shape')) == 2",
  "src_out_tensor": [
   "AveragePool:out0"
  ],
  "param_map": {
   "pooling": {
    "pad_method": [
     "STRING",
     "CODE",
     "'auto' if self.attr_pick(node['AveragePool'], 'pads', None) == None else 'padding_const'"
    ],
    "pad": [
     "INTS",
     "CODE",
     "[str(p) for p in self.array_layout(self.attr_pick(node['AveragePool'], 'pads', [ 0, 0, 0, 0]), [0, 2, 1, 3])]"
    ],
    "ksize_h": [
     "INT",
     "CODE",
     "self.attr_pick(node['AveragePool'], 'kernel_shape')[0]"
    ],
    "pad_w": [
     "INT",
     "CODE",
     "self.attr_pick(node['AveragePool'], 'pads', [0, 0, 0, 0])[1]"
    ],
    "ksize_w": [
     "INT",
     "CODE",
     "self.attr_pick(node['AveragePool'], 'kernel_shape')[1]"
    ],
    "type": [
     "STRING",
     "VALUE",
     "AVG"
    ],
    "stride_h": [
     "INT",
     "CODE",
     "self.attr_pick(node['AveragePool'], 'strides', [1, 1])[0]"
    ],
    "stride_w": [
     "INT",
     "CODE",
     "self.attr_pick(node['AveragePool'], 'strides', [1, 1])[1]"
    ],
    "round_type": [
     "STRING",
     "CODE",
     "'ceil' if self.attr_pick(node['AveragePool'], 'ceil_mode') == 1 else 'floor'"
    ],
    "padding": [
     "STRING",
     "CODE",
     "'SAME' if self.attr_pick(node['AveragePool'], 'auto_pad', 'NOTSET') in ['SAME_UPPER', 'SAME_LOWER'] else 'VALID'"
    ],
    "pad_h": [
     "INT",
     "CODE",
     "self.attr_pick(node['AveragePool'], 'pads', [0, 0, 0, 0])[0]"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "AveragePool:out0",
    "pool1d:out0"
   ]
  ],
  "acu_lys_alias": [
   "pool1d"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "pool1d:in0"
   ]
  ],
  "ruler_name": "r_avgpool1d",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "AveragePool:in0"
   ]
  ],
  "src_ops_alias": [
   "AveragePool"
  ],
  "blob_map": {},
  "pre_condition": "len(self.attr_pick(node['AveragePool'], 'kernel_shape')) == 1",
  "src_out_tensor": [
   "AveragePool:out0"
  ],
  "param_map": {
   "pool1d": {
    "pad_method": [
     "STRING",
     "CODE",
     "'padding_const' if self.attr_pick(node['AveragePool'], 'auto_pad', 'NOTSET') == 'NOTSET' else 'auto'"
    ],
    "stride": [
     "INT",
     "CODE",
     "self.attr_pick(node['AveragePool'], 'strides', [1])[0]"
    ],
    "ksize": [
     "INT",
     "CODE",
     "self.attr_pick(node['AveragePool'], 'kernel_shape')[0]"
    ],
    "pad": [
     "INTS",
     "CODE",
     "[str(p) for p in self.array_layout(self.attr_pick(node['AveragePool'], 'pads', [ 0, 0]), [0, 1])]"
    ],
    "type": [
     "STRING",
     "VALUE",
     "AVG"
    ],
    "padding": [
     "STRING",
     "CODE",
     "'SAME' if self.attr_pick(node['AveragePool'], 'auto_pad', 'NOTSET') in ['SAME_UPPER', 'SAME_LOWER'] else 'VALID'"
    ],
    "round_type": [
     "STRING",
     "CODE",
     "'ceil' if self.attr_pick(node['AveragePool'], 'ceil_mode') == 1 else 'floor'"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "AveragePool:out0",
    "pool3d:out0"
   ]
  ],
  "acu_lys_alias": [
   "pool3d"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "pool3d:in0"
   ]
  ],
  "ruler_name": "r_avgpool3d",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "AveragePool:in0"
   ]
  ],
  "src_ops_alias": [
   "AveragePool"
  ],
  "blob_map": {
   "pool3d": {}
  },
  "pre_condition": "len(self.attr_pick(node['AveragePool'], 'kernel_shape')) == 3",
  "src_out_tensor": [
   "AveragePool:out0"
  ],
  "param_map": {
   "pool3d": {
    "pad_method": [
     "STRING",
     "CODE",
     "'auto' if self.attr_pick(node['AveragePool'], 'pads', None) == None else 'padding_const'"
    ],
    "ksize_h": [
     "INT",
     "CODE",
     "self.attr_pick(node['AveragePool'], 'kernel_shape')[0]"
    ],
    "type": [
     "STRING",
     "VALUE",
     "AVG"
    ],
    "pad_d": [
     "INT",
     "CODE",
     "self.attr_pick(node['AveragePool'], 'pads', [0, 0, 0, 0, 0, 0])[2]"
    ],
    "pad_w": [
     "INT",
     "CODE",
     "self.attr_pick(node['AveragePool'], 'pads', [0, 0, 0, 0, 0, 0])[1]"
    ],
    "padding": [
     "STRING",
     "CODE",
     "'SAME' if self.attr_pick(node['AveragePool'], 'auto_pad', 'NOTSET') in ['SAME_UPPER', 'SAME_LOWER'] else 'VALID'"
    ],
    "stride_d": [
     "INT",
     "CODE",
     "self.attr_pick(node['AveragePool'], 'strides', [1, 1, 1])[2]"
    ],
    "pad_h": [
     "INT",
     "CODE",
     "self.attr_pick(node['AveragePool'], 'pads', [0, 0, 0, 0, 0, 0])[0]"
    ],
    "pad": [
     "INTS",
     "CODE",
     "[str(p) for p in self.array_layout(self.attr_pick(node['AveragePool'], 'pads', [ 0, 0, 0, 0, 0, 0]), [0, 2, 4, 1, 3, 5])]"
    ],
    "ksize_w": [
     "INT",
     "CODE",
     "self.attr_pick(node['AveragePool'], 'kernel_shape')[1]"
    ],
    "stride_h": [
     "INT",
     "CODE",
     "self.attr_pick(node['AveragePool'], 'strides', [1, 1, 1])[0]"
    ],
    "stride_w": [
     "INT",
     "CODE",
     "self.attr_pick(node['AveragePool'], 'strides', [1, 1, 1])[1]"
    ],
    "round_type": [
     "STRING",
     "CODE",
     "'ceil' if self.attr_pick(node['AveragePool'], 'ceil_mode') == 1 else 'floor'"
    ],
    "ksize_d": [
     "INT",
     "CODE",
     "self.attr_pick(node['AveragePool'], 'kernel_shape')[2]"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "GlobalAveragePool:out0",
    "pooling:out0"
   ]
  ],
  "acu_lys_alias": [
   "pooling"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "pooling:in0"
   ]
  ],
  "ruler_name": "r_global_avgpool",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "GlobalAveragePool:in0"
   ]
  ],
  "src_ops_alias": [
   "GlobalAveragePool"
  ],
  "blob_map": {},
  "pre_condition": "len(self.shape_pick(tensor['I:out0'])) == 4",
  "src_out_tensor": [
   "GlobalAveragePool:out0"
  ],
  "param_map": {
   "pooling": {
    "pad_method": [
     "STRING",
     "VALUE",
     "padding_const"
    ],
    "global_pooling": [
     "BOOL",
     "VALUE",
     true
    ],
    "pad_w": [
     "INT",
     "CODE",
     "self.attr_pick(node['GlobalAveragePool'], 'pads', [0, 0, 0, 0])[1]"
    ],
    "pad": [
     "INTS",
     "CODE",
     "[str(p) for p in self.array_layout(self.attr_pick(node['GlobalAveragePool'], 'pads', [ 0, 0, 0, 0]), [0, 2, 1, 3])]"
    ],
    "type": [
     "STRING",
     "VALUE",
     "AVG"
    ],
    "round_type": [
     "STRING",
     "VALUE",
     "floor"
    ],
    "padding": [
     "STRING",
     "VALUE",
     "VALID"
    ],
    "pad_h": [
     "INT",
     "CODE",
     "self.attr_pick(node['GlobalAveragePool'], 'pads', [0, 0, 0, 0])[0]"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "GlobalAveragePool:out0",
    "pool1d:out0"
   ]
  ],
  "acu_lys_alias": [
   "pool1d"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "pool1d:in0"
   ]
  ],
  "ruler_name": "r_global_avgpool1d",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "GlobalAveragePool:in0"
   ]
  ],
  "src_ops_alias": [
   "GlobalAveragePool"
  ],
  "blob_map": {},
  "pre_condition": "len(self.shape_pick(tensor['I:out0'])) == 3",
  "src_out_tensor": [
   "GlobalAveragePool:out0"
  ],
  "param_map": {
   "pool1d": {
    "pad_method": [
     "STRING",
     "VALUE",
     "padding_const"
    ],
    "pad": [
     "INTS",
     "CODE",
     "[str(p) for p in self.array_layout(self.attr_pick(node['GlobalAveragePool'], 'pads', [ 0, 0]), [0, 1])]"
    ],
    "type": [
     "STRING",
     "VALUE",
     "AVG"
    ],
    "global_pooling": [
     "BOOL",
     "VALUE",
     true
    ],
    "padding": [
     "STRING",
     "VALUE",
     "VALID"
    ],
    "round_type": [
     "STRING",
     "VALUE",
     "floor"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "GlobalMaxPool:out0",
    "pooling:out0"
   ]
  ],
  "acu_lys_alias": [
   "pooling"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "pooling:in0"
   ]
  ],
  "ruler_name": "r_global_maxpool",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "GlobalMaxPool:in0"
   ]
  ],
  "src_ops_alias": [
   "GlobalMaxPool"
  ],
  "blob_map": {},
  "pre_condition": "len(self.shape_pick(tensor['I:out0'])) == 4",
  "src_out_tensor": [
   "GlobalMaxPool:out0"
  ],
  "param_map": {
   "pooling": {
    "pad_method": [
     "STRING",
     "VALUE",
     "padding_const"
    ],
    "global_pooling": [
     "BOOL",
     "VALUE",
     true
    ],
    "pad_w": [
     "INT",
     "CODE",
     "self.attr_pick(node['GlobalMaxPool'], 'pads', [0, 0, 0, 0])[1]"
    ],
    "pad": [
     "INTS",
     "CODE",
     "[str(p) for p in self.array_layout(self.attr_pick(node['GlobalMaxPool'], 'pads', [ 0, 0, 0, 0]), [0, 2, 1, 3])]"
    ],
    "type": [
     "STRING",
     "VALUE",
     "MAX"
    ],
    "round_type": [
     "STRING",
     "VALUE",
     "floor"
    ],
    "padding": [
     "STRING",
     "VALUE",
     "VALID"
    ],
    "pad_h": [
     "INT",
     "CODE",
     "self.attr_pick(node['GlobalMaxPool'], 'pads', [0, 0, 0, 0])[0]"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "GlobalMaxPool:out0",
    "pool1d:out0"
   ]
  ],
  "acu_lys_alias": [
   "pool1d"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "pool1d:in0"
   ]
  ],
  "ruler_name": "r_global_maxpool1d",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "GlobalMaxPool:in0"
   ]
  ],
  "src_ops_alias": [
   "GlobalMaxPool"
  ],
  "blob_map": {},
  "pre_condition": "len(self.shape_pick(tensor['I:out0'])) == 3",
  "src_out_tensor": [
   "GlobalMaxPool:out0"
  ],
  "param_map": {
   "pool1d": {
    "pad_method": [
     "STRING",
     "VALUE",
     "padding_const"
    ],
    "pad": [
     "INTS",
     "CODE",
     "[str(p) for p in self.array_layout(self.attr_pick(node['GlobalMaxPool'], 'pads', [ 0, 0]), [0, 1])]"
    ],
    "type": [
     "STRING",
     "VALUE",
     "MAX"
    ],
    "global_pooling": [
     "BOOL",
     "VALUE",
     true
    ],
    "padding": [
     "STRING",
     "VALUE",
     "VALID"
    ],
    "round_type": [
     "STRING",
     "VALUE",
     "floor"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   4
  ],
  "src_acu_out_tensor_map": [
   [
    "Reshape:out0",
    "reshape:out0"
   ]
  ],
  "acu_lys_alias": [
   "reshape"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "reshape:in0"
   ]
  ],
  "ruler_name": "r_rsp_v1",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Reshape:in0"
   ]
  ],
  "src_ops_alias": [
   "Reshape"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "Reshape:out0"
  ],
  "param_map": {
   "reshape": {
    "shape": [
     "STRING",
     "CODE",
     "self.shape_pick(tensor['Reshape:out0'])"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   5,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Reshape:out0",
    "reshape:out0"
   ]
  ],
  "acu_lys_alias": [
   "reshape"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "reshape:in0"
   ]
  ],
  "ruler_name": "r_rsp_v5",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Reshape:in0"
   ]
  ],
  "src_ops_alias": [
   "Reshape",
   "Constant_0"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "Reshape:out0"
  ],
  "param_map": {
   "reshape": {
    "shape": [
     "INTS",
     "CODE",
     "self.tensor_to_numpy(tensor['Constant_0:out0'])"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant_0:out0",
    "Reshape:in1"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   5,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Reshape:out0",
    "variable:out0"
   ]
  ],
  "acu_lys_alias": [
   "variable"
  ],
  "src_acu_in_tensor_map": [],
  "ruler_name": "r_rsp_v5x",
  "priority_tip": 0,
  "src_in_anchor": [],
  "src_ops_alias": [
   "Reshape",
   "Constant_0",
   "Constant_1"
  ],
  "blob_map": {
   "variable": {
    "data": [
     "CODE",
     "np.reshape(self.tensor_to_numpy(tensor['Constant_0:out0']), self.tensor_to_numpy(tensor['Constant_1:out0']).astype(np.int32).tolist())"
    ]
   }
  },
  "pre_condition": null,
  "src_out_tensor": [
   "Reshape:out0"
  ],
  "param_map": {
   "variable": {
    "shape": [
     "ORIGIN",
     "CODE",
     "self.shape_pick(tensor['Reshape:out0'])"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant_0:out0",
    "Reshape:in0"
   ],
   [
    "Constant_1:out0",
    "Reshape:in1"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   5,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Reshape:out0",
    "reshape:out0"
   ]
  ],
  "acu_lys_alias": [
   "reshape"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "reshape:in0"
   ]
  ],
  "ruler_name": "r_dynamic_rsp_5x",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Reshape:in0"
   ],
   [
    "I_1:out0",
    "Reshape:in1"
   ]
  ],
  "src_ops_alias": [
   "Reshape"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "Reshape:out0"
  ],
  "param_map": {
   "reshape": {
    "shape": [
     "INTS",
     "CODE",
     "self.tensor_to_numpy(tensor['I_1:out0'])"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Squeeze:out0",
    "reshape:out0"
   ]
  ],
  "acu_lys_alias": [
   "reshape"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "reshape:in0"
   ]
  ],
  "ruler_name": "r_squeeze_with_constant",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Squeeze:in0"
   ]
  ],
  "src_ops_alias": [
   "Squeeze",
   "Constant_0"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "Squeeze:out0"
  ],
  "param_map": {
   "reshape": {
    "shape": [
     "INTS",
     "CODE",
     "self.squeeze_shapes(self.attr_pick(node['Squeeze'], 'axes', None), self.shape_pick(tensor['Constant_0:out0']))"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Squeeze:out0",
    "squeeze:out0"
   ]
  ],
  "acu_lys_alias": [
   "squeeze"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "squeeze:in0"
   ]
  ],
  "ruler_name": "r_squeeze",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "Squeeze:in0"
   ]
  ],
  "src_ops_alias": [
   "Squeeze"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "Squeeze:out0"
  ],
  "param_map": {
   "squeeze": {
    "axis_list": [
     "ORIGIN",
     "CODE",
     "self.attr_pick(node['Squeeze'], 'axes', None)"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   13,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Squeeze:out0",
    "squeeze:out0"
   ]
  ],
  "acu_lys_alias": [
   "squeeze"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "squeeze:in0"
   ]
  ],
  "ruler_name": "r_squeeze_with_constant_axes",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "Squeeze:in0"
   ]
  ],
  "src_ops_alias": [
   "Squeeze",
   "Constant_0"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "Squeeze:out0"
  ],
  "param_map": {
   "squeeze": {
    "axis_list": [
     "ORIGIN",
     "CODE",
     "self.tensor_to_numpy(tensor['Constant_0:out0']).tolist()"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant_0:out0",
    "Squeeze:in1"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Unsqueeze:out0",
    "reshape:out0"
   ]
  ],
  "acu_lys_alias": [
   "reshape"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "reshape:in0"
   ]
  ],
  "ruler_name": "r_unsqueeze",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "Unsqueeze:in0"
   ]
  ],
  "src_ops_alias": [
   "Unsqueeze"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "Unsqueeze:out0"
  ],
  "param_map": {
   "reshape": {
    "shape": [
     "INTS",
     "CODE",
     "self.unsqueeze_shape(self.attr_pick(node['Unsqueeze'], 'axes'), self.shape_pick(tensor['I_0:out0']))"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   13,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Unsqueeze:out0",
    "reshape:out0"
   ]
  ],
  "acu_lys_alias": [
   "reshape"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "reshape:in0"
   ]
  ],
  "ruler_name": "r_unsqueeze_with_constant_axes",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "Unsqueeze:in0"
   ]
  ],
  "src_ops_alias": [
   "Unsqueeze",
   "Constant_0"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "Unsqueeze:out0"
  ],
  "param_map": {
   "reshape": {
    "shape": [
     "INTS",
     "CODE",
     "self.unsqueeze_shape(self.tensor_to_numpy(tensor['Constant_0:out0']).tolist(), self.shape_pick(tensor['I_0:out0']))"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant_0:out0",
    "Unsqueeze:in1"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Flatten:out0",
    "reshape:out0"
   ]
  ],
  "acu_lys_alias": [
   "reshape"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "reshape:in0"
   ]
  ],
  "ruler_name": "r_flatten",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Flatten:in0"
   ]
  ],
  "src_ops_alias": [
   "Flatten"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "Flatten:out0"
  ],
  "param_map": {
   "reshape": {
    "shape": [
     "INTS",
     "VALUE",
     [
      0,
      -1
     ]
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Transpose:out0",
    "permute:out0"
   ]
  ],
  "acu_lys_alias": [
   "permute"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "permute:in0"
   ]
  ],
  "ruler_name": "r_transpose",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Transpose:in0"
   ]
  ],
  "src_ops_alias": [
   "Transpose"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "Transpose:out0"
  ],
  "param_map": {
   "permute": {
    "perm": [
     "STRING",
     "PYFUNC",
     [
      "def r_permute_value(self, node, tensor):",
      "    in_shape = self.shape_pick(tensor['I:out0'])",
      "    perm = self.attr_pick(node['Transpose'], 'perm', None)",
      "    if perm is None:",
      "        perm = list()",
      "        for idx in range(len(in_shape)):",
      "            perm.append(idx)",
      "        perm.reverse()",
      "    _perm = \" \".join([str(x) for x in perm])",
      "    return _perm",
      ""
     ]
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Softmax:out0",
    "softmax:out0"
   ]
  ],
  "acu_lys_alias": [
   "softmax"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "softmax:in0"
   ]
  ],
  "ruler_name": "r_softmax",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Softmax:in0"
   ]
  ],
  "src_ops_alias": [
   "Softmax"
  ],
  "blob_map": {},
  "pre_condition": [
   "def r_softmax_pre_cond(self, node, tensor):",
   "    axis = self.attr_pick(node['Softmax'], 'axis', -1)",
   "    input_rank = len(self.shape_pick(tensor['I:out0']))",
   "    if axis < 0:",
   "        axis = input_rank + axis",
   "    if self.minor_version < 13:",
   "        if input_rank > 2:",
   "            if axis == input_rank - 1:",
   "                return True",
   "        elif input_rank == 2:",
   "            return True",
   "        return False",
   "    return True",
   ""
  ],
  "src_out_tensor": [
   "Softmax:out0"
  ],
  "param_map": {
   "softmax": {
    "sf_axis": [
     "INT",
     "PYFUNC",
     [
      "def r_softmax_get_sf_axis(self, node, tensor):",
      "    axis = self.attr_pick(node['Softmax'], 'axis', None)",
      "    if axis is None:",
      "        shape = self.shape_pick(tensor['I:out0'])",
      "        if len(shape) == 4 and self.minor_version < 13:",
      "            axis = 1",
      "        else:",
      "            axis = -1",
      "    return axis",
      ""
     ]
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "LogSoftmax:out0",
    "log_softmax:out0"
   ]
  ],
  "acu_lys_alias": [
   "log_softmax"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "log_softmax:in0"
   ]
  ],
  "ruler_name": "r_log_softmax",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "LogSoftmax:in0"
   ]
  ],
  "src_ops_alias": [
   "LogSoftmax"
  ],
  "blob_map": {
   "log_softmax": {}
  },
  "pre_condition": [
   "def r_logsoftmax_pre_cond(self, node, tensor):",
   "    axis = self.attr_pick(node['LogSoftmax'], 'axis', -1)",
   "    input_rank = len(self.shape_pick(tensor['I:out0']))",
   "    if axis < 0:",
   "        axis = input_rank + axis",
   "    if self.minor_version < 13:",
   "        if input_rank > 2:",
   "            if axis == input_rank - 1:",
   "                return True",
   "        elif input_rank == 2:",
   "            return True",
   "        return False",
   "    return True",
   ""
  ],
  "src_out_tensor": [
   "LogSoftmax:out0"
  ],
  "param_map": {
   "log_softmax": {
    "sf_axis": [
     "INT",
     "PYFUNC",
     [
      "def r_softmax_get_log_sf_axis(self, node, tensor):",
      "    axis = self.attr_pick(node['LogSoftmax'], 'axis', None)",
      "    if axis is None:",
      "        shape = self.shape_pick(tensor['I:out0'])",
      "        if len(shape) == 4 and self.minor_version < 13:",
      "            axis = 1",
      "        else:",
      "            axis = -1",
      "    return axis",
      ""
     ]
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Softsign:out0",
    "divide:out0"
   ]
  ],
  "acu_lys_alias": [
   "abs",
   "add",
   "divide",
   "variable"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "abs:in0"
   ],
   [
    "I_0:out0",
    "divide:in0"
   ]
  ],
  "ruler_name": "r_softsign",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "Softsign:in0"
   ]
  ],
  "src_ops_alias": [
   "Softsign"
  ],
  "blob_map": {
   "variable": {
    "data": [
     "CODE",
     "np.ones([1], dtype=np.float32)"
    ]
   }
  },
  "pre_condition": null,
  "src_out_tensor": [
   "Softsign:out0"
  ],
  "param_map": {},
  "src_inter_flow": [],
  "acu_inter_flow": [
   [
    "variable:out0",
    "add:in0"
   ],
   [
    "abs:out0",
    "add:in1"
   ],
   [
    "add:out0",
    "divide:in1"
   ]
  ]
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   6
  ],
  "src_acu_out_tensor_map": [
   [
    "Dropout:out0",
    "dropout:out0"
   ]
  ],
  "acu_lys_alias": [
   "dropout"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "dropout:in0"
   ]
  ],
  "ruler_name": "dropout_out2_as_dropout_1_6",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "Dropout:in0"
   ]
  ],
  "src_ops_alias": [
   "Dropout"
  ],
  "blob_map": {
   "dropout": {}
  },
  "pre_condition": "self.attr_pick(node['Dropout'], 'is_test', 0) == 0 and math.isclose(0.0, self.attr_pick(node['Dropout'], 'ratio', 0.5)) == False",
  "src_out_tensor": [
   "Dropout:out0",
   "Dropout:out1"
  ],
  "param_map": {
   "dropout": {
    "ratio": [
     "FLOAT",
     "CODE",
     "self.attr_pick(node['Dropout'], 'ratio', 0.5)"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   6
  ],
  "src_acu_out_tensor_map": [
   [
    "Dropout:out0",
    "noop:out0"
   ]
  ],
  "acu_lys_alias": [
   "noop"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "noop:in0"
   ]
  ],
  "ruler_name": "dropout_out2_as_noop_1_6",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "Dropout:in0"
   ]
  ],
  "src_ops_alias": [
   "Dropout"
  ],
  "blob_map": {
   "noop": {}
  },
  "pre_condition": "self.attr_pick(node['Dropout'], 'is_test', 0) != 0 or math.isclose(0.0, self.attr_pick(node['Dropout'], 'ratio', 0.5)) == True",
  "src_out_tensor": [
   "Dropout:out0",
   "Dropout:out1"
  ],
  "param_map": {
   "noop": {}
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   6
  ],
  "src_acu_out_tensor_map": [
   [
    "Dropout:out0",
    "dropout:out0"
   ]
  ],
  "acu_lys_alias": [
   "dropout"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "dropout:in0"
   ]
  ],
  "ruler_name": "r_dropout_out1_as_dropout_1_6",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Dropout:in0"
   ]
  ],
  "src_ops_alias": [
   "Dropout"
  ],
  "blob_map": {},
  "pre_condition": "self.attr_pick(node['Dropout'], 'is_test', 0) == 0 and math.isclose(0.0, self.attr_pick(node['Dropout'], 'ratio', 0.5)) == False",
  "src_out_tensor": [
   "Dropout:out0"
  ],
  "param_map": {
   "dropout": {
    "ratio": [
     "FLOAT",
     "CODE",
     "self.attr_pick(node['Dropout'], 'ratio', 0.5)"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   6
  ],
  "src_acu_out_tensor_map": [
   [
    "Dropout:out0",
    "noop:out0"
   ]
  ],
  "acu_lys_alias": [
   "noop"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "noop:in0"
   ]
  ],
  "ruler_name": "r_dropout_out1_as_noop_1_6",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Dropout:in0"
   ]
  ],
  "src_ops_alias": [
   "Dropout"
  ],
  "blob_map": {},
  "pre_condition": "self.attr_pick(node['Dropout'], 'is_test', 0) != 0 or math.isclose(0.0, self.attr_pick(node['Dropout'], 'ratio', 0.5)) == True",
  "src_out_tensor": [
   "Dropout:out0"
  ],
  "param_map": {},
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   7,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Dropout:out0",
    "dropout:out0"
   ]
  ],
  "acu_lys_alias": [
   "dropout"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "dropout:in0"
   ]
  ],
  "ruler_name": "dropout_out2_as_dropout_7",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "Dropout:in0"
   ]
  ],
  "src_ops_alias": [
   "Dropout"
  ],
  "blob_map": {
   "dropout": {}
  },
  "pre_condition": "math.isclose(0.0, self.attr_pick(node['Dropout'], 'ratio', 0.5)) == False",
  "src_out_tensor": [
   "Dropout:out0",
   "Dropout:out1"
  ],
  "param_map": {
   "dropout": {
    "ratio": [
     "FLOAT",
     "CODE",
     "self.attr_pick(node['Dropout'], 'ratio', 0.5)"
    ],
    "scale_train": [
     "BOOL",
     "VALUE",
     "True"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   7,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Dropout:out0",
    "noop:out0"
   ]
  ],
  "acu_lys_alias": [
   "noop"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "noop:in0"
   ]
  ],
  "ruler_name": "dropout_out2_as_noop_7",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "Dropout:in0"
   ]
  ],
  "src_ops_alias": [
   "Dropout"
  ],
  "blob_map": {
   "dropout": {}
  },
  "pre_condition": "math.isclose(0.0, self.attr_pick(node['Dropout'], 'ratio', 0.5)) == True",
  "src_out_tensor": [
   "Dropout:out0",
   "Dropout:out1"
  ],
  "param_map": {
   "dropout": {
    "ratio": [
     "FLOAT",
     "CODE",
     "self.attr_pick(node['Dropout'], 'ratio', 0.5)"
    ],
    "scale_train": [
     "BOOL",
     "VALUE",
     "True"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   7,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Dropout:out0",
    "dropout:out0"
   ]
  ],
  "acu_lys_alias": [
   "dropout"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "dropout:in0"
   ]
  ],
  "ruler_name": "r_dropout_out1_as_dropout_7",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Dropout:in0"
   ]
  ],
  "src_ops_alias": [
   "Dropout"
  ],
  "blob_map": {},
  "pre_condition": "math.isclose(0.0, self.attr_pick(node['Dropout'], 'ratio', 0.5)) == False",
  "src_out_tensor": [
   "Dropout:out0"
  ],
  "param_map": {
   "dropout": {
    "ratio": [
     "FLOAT",
     "CODE",
     "self.attr_pick(node['Dropout'], 'ratio', 0.5)"
    ],
    "scale_train": [
     "BOOL",
     "VALUE",
     "True"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   7,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Dropout:out0",
    "noop:out0"
   ]
  ],
  "acu_lys_alias": [
   "noop"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "noop:in0"
   ]
  ],
  "ruler_name": "r_dropout_out1_as_noop_7",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Dropout:in0"
   ]
  ],
  "src_ops_alias": [
   "Dropout"
  ],
  "blob_map": {},
  "pre_condition": "math.isclose(0.0, self.attr_pick(node['Dropout'], 'ratio', 0.5)) == True",
  "src_out_tensor": [
   "Dropout:out0"
  ],
  "param_map": {
   "dropout": {
    "ratio": [
     "FLOAT",
     "CODE",
     "self.attr_pick(node['Dropout'], 'ratio', 0.5)"
    ],
    "scale_train": [
     "BOOL",
     "VALUE",
     "True"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "LRN:out0",
    "localresponsenormalization:out0"
   ]
  ],
  "acu_lys_alias": [
   "localresponsenormalization"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "localresponsenormalization:in0"
   ]
  ],
  "ruler_name": "r_lrn",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "LRN:in0"
   ]
  ],
  "src_ops_alias": [
   "LRN"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "LRN:out0"
  ],
  "param_map": {
   "localresponsenormalization": {
    "alpha": [
     "FLOAT",
     "CODE",
     "self.attr_pick(node['LRN'], 'alpha', 1e-4)"
    ],
    "type": [
     "STRING",
     "VALUE",
     "NORM_ACROSS_CHANNELS"
    ],
    "local_size": [
     "INT",
     "CODE",
     "self.attr_pick(node['LRN'], 'size')"
    ],
    "beta": [
     "FLOAT",
     "CODE",
     "self.attr_pick(node['LRN'], 'beta', 0.75)"
    ],
    "bias": [
     "FLOAT",
     "CODE",
     "self.attr_pick(node['LRN'], 'bias', 1.0)"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Div:out0",
    "l2normalize:out0"
   ]
  ],
  "acu_lys_alias": [
   "l2normalize"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "l2normalize:in0"
   ]
  ],
  "ruler_name": "r_reducel2_div_2_l2normalize",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "Div:in0"
   ],
   [
    "I_0:out0",
    "ReduceL2:in0"
   ]
  ],
  "src_ops_alias": [
   "Div",
   "ReduceL2"
  ],
  "blob_map": {
   "l2normalize": {}
  },
  "pre_condition": "self.attr_pick(node['ReduceL2'], 'keepdims') == 1",
  "src_out_tensor": [
   "Div:out0"
  ],
  "param_map": {
   "l2normalize": {
    "l2n_dim": [
     "INTS",
     "CODE",
     "self.attr_pick(node['ReduceL2'], 'axes')"
    ]
   }
  },
  "src_inter_flow": [
   [
    "ReduceL2:out0",
    "Div:in1"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   5,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Mul:out0",
    "l2normalizescale:out0"
   ]
  ],
  "acu_lys_alias": [
   "l2normalizescale"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "l2normalizescale:in0"
   ]
  ],
  "ruler_name": "l2normalaize_scale",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "Div:in0"
   ],
   [
    "I_0:out0",
    "Pow:in0"
   ]
  ],
  "src_ops_alias": [
   "Mul",
   "Div",
   "Reshape",
   "Add",
   "Constant",
   "Constant_1",
   "Sqrt",
   "Constant_2",
   "ReduceSum",
   "Pow",
   "Constant_3"
  ],
  "blob_map": {
   "l2normalizescale": {
    "scale": [
     "CODE",
     "np.reshape(self.tensor_to_numpy(tensor['Constant:out0']), self.array_layout(self.tensor_to_numpy(tensor['Constant_1:out0']).astype(np.int32).tolist(), [0, 2, 3, 1]))"
    ]
   }
  },
  "pre_condition": "(self.tensor_to_numpy(tensor['Constant_3:out0']) == 2.0).all() and  self.attr_pick(node['ReduceSum'], 'axes') == [1]",
  "src_out_tensor": [
   "Mul:out0"
  ],
  "param_map": {
   "l2normalizescale": {
    "l2n_dim": [
     "ORIGIN",
     "VALUE",
     -1
    ]
   }
  },
  "src_inter_flow": [
   [
    "Div:out0",
    "Mul:in0"
   ],
   [
    "Reshape:out0",
    "Mul:in1"
   ],
   [
    "Add:out0",
    "Div:in1"
   ],
   [
    "Constant:out0",
    "Reshape:in0"
   ],
   [
    "Constant_1:out0",
    "Reshape:in1"
   ],
   [
    "Sqrt:out0",
    "Add:in0"
   ],
   [
    "Constant_2:out0",
    "Add:in1"
   ],
   [
    "ReduceSum:out0",
    "Sqrt:in0"
   ],
   [
    "Pow:out0",
    "ReduceSum:in0"
   ],
   [
    "Constant_3:out0",
    "Pow:in1"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   6,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "InstanceNormalization:out0",
    "instancenormalize:out0"
   ]
  ],
  "acu_lys_alias": [
   "instancenormalize"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "instancenormalize:in0"
   ]
  ],
  "ruler_name": "r_instancenorm",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "InstanceNormalization:in0"
   ]
  ],
  "src_ops_alias": [
   "InstanceNormalization",
   "Constant_0",
   "Constant_1"
  ],
  "blob_map": {
   "instancenormalize": {
    "bias": [
     "CODE",
     "self.tensor_to_numpy(tensor['Constant_1:out0'])"
    ],
    "scale": [
     "CODE",
     "self.tensor_to_numpy(tensor['Constant_0:out0'])"
    ]
   }
  },
  "pre_condition": null,
  "src_out_tensor": [
   "InstanceNormalization:out0"
  ],
  "param_map": {
   "instancenormalize": {
    "axis": [
     "INTS",
     "CODE",
     "list(range(2, len(self.attr_pick(node['InstanceNormalization'], '_out_shape')[0])))"
    ],
    "eps": [
     "FLOAT",
     "CODE",
     "self.attr_pick(node['InstanceNormalization'], 'epsilon', 1e-5)"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant_0:out0",
    "InstanceNormalization:in1"
   ],
   [
    "Constant_1:out0",
    "InstanceNormalization:in2"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Add:out0",
    "add:out0"
   ]
  ],
  "acu_lys_alias": [
   "add"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "add:in0"
   ],
   [
    "I_1:out0",
    "add:in1"
   ]
  ],
  "ruler_name": "r_add",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Add:in0"
   ],
   [
    "I_1:out0",
    "Add:in1"
   ]
  ],
  "src_ops_alias": [
   "Add"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "Add:out0"
  ],
  "param_map": {},
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Sub:out0",
    "subtract:out0"
   ]
  ],
  "acu_lys_alias": [
   "subtract"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "subtract:in0"
   ],
   [
    "I_1:out0",
    "subtract:in1"
   ]
  ],
  "ruler_name": "r_sub",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Sub:in0"
   ],
   [
    "I_1:out0",
    "Sub:in1"
   ]
  ],
  "src_ops_alias": [
   "Sub"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "Sub:out0"
  ],
  "param_map": {},
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Mul:out0",
    "multiply:out0"
   ]
  ],
  "acu_lys_alias": [
   "multiply"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "multiply:in0"
   ],
   [
    "I_1:out0",
    "multiply:in1"
   ]
  ],
  "ruler_name": "r_mul",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Mul:in0"
   ],
   [
    "I_1:out0",
    "Mul:in1"
   ]
  ],
  "src_ops_alias": [
   "Mul"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "Mul:out0"
  ],
  "param_map": {},
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Mul:out0",
    "multiply:out0"
   ]
  ],
  "acu_lys_alias": [
   "multiply"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "multiply:in0"
   ],
   [
    "I:out0",
    "multiply:in1"
   ]
  ],
  "ruler_name": "r_mul_with_same_input",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Mul:in0"
   ],
   [
    "I:out0",
    "Mul:in1"
   ]
  ],
  "src_ops_alias": [
   "Mul"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "Mul:out0"
  ],
  "param_map": {},
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Div:out0",
    "real_div:out0"
   ]
  ],
  "acu_lys_alias": [
   "real_div"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "real_div:in0"
   ],
   [
    "I_1:out0",
    "real_div:in1"
   ]
  ],
  "ruler_name": "r_div",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Div:in0"
   ],
   [
    "I_1:out0",
    "Div:in1"
   ]
  ],
  "src_ops_alias": [
   "Div"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "Div:out0"
  ],
  "param_map": {},
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Mod:out0",
    "mod:out0"
   ]
  ],
  "acu_lys_alias": [
   "mod"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "mod:in0"
   ],
   [
    "I_1:out0",
    "mod:in1"
   ]
  ],
  "ruler_name": "r_mod",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Mod:in0"
   ],
   [
    "I_1:out0",
    "Mod:in1"
   ]
  ],
  "src_ops_alias": [
   "Mod"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "Mod:out0"
  ],
  "param_map": {
   "mod": {
    "fmod": [
     "INT",
     "CODE",
     "self.attr_pick(node['Mod'], 'fmod', 0)"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Or:out0",
    "logical_or:out0"
   ]
  ],
  "acu_lys_alias": [
   "logical_or"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "logical_or:in0"
   ],
   [
    "I_1:out0",
    "logical_or:in1"
   ]
  ],
  "ruler_name": "r_logical_or",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Or:in0"
   ],
   [
    "I_1:out0",
    "Or:in1"
   ]
  ],
  "src_ops_alias": [
   "Or"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "Or:out0"
  ],
  "param_map": {},
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "And:out0",
    "logical_and:out0"
   ]
  ],
  "acu_lys_alias": [
   "logical_and"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "logical_and:in0"
   ],
   [
    "I_1:out0",
    "logical_and:in1"
   ]
  ],
  "ruler_name": "r_logical_and",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "And:in0"
   ],
   [
    "I_1:out0",
    "And:in1"
   ]
  ],
  "src_ops_alias": [
   "And"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "And:out0"
  ],
  "param_map": {},
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Greater:out0",
    "greater:out0"
   ]
  ],
  "acu_lys_alias": [
   "greater"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "greater:in0"
   ],
   [
    "I_1:out0",
    "greater:in1"
   ]
  ],
  "ruler_name": "r_greater",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Greater:in0"
   ],
   [
    "I_1:out0",
    "Greater:in1"
   ]
  ],
  "src_ops_alias": [
   "Greater"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "Greater:out0"
  ],
  "param_map": {},
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   12,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "GreaterOrEqual:out0",
    "greater_equal:out0"
   ]
  ],
  "acu_lys_alias": [
   "greater_equal"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "greater_equal:in0"
   ],
   [
    "I_1:out0",
    "greater_equal:in1"
   ]
  ],
  "ruler_name": "r_greater_equal",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "GreaterOrEqual:in0"
   ],
   [
    "I_1:out0",
    "GreaterOrEqual:in1"
   ]
  ],
  "src_ops_alias": [
   "GreaterOrEqual"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "GreaterOrEqual:out0"
  ],
  "param_map": {},
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Abs:out0",
    "abs:out0"
   ]
  ],
  "acu_lys_alias": [
   "abs"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "abs:in0"
   ]
  ],
  "ruler_name": "r_abs",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Abs:in0"
   ]
  ],
  "src_ops_alias": [
   "Abs"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "Abs:out0"
  ],
  "param_map": {},
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Ceil:out0",
    "ceil:out0"
   ]
  ],
  "acu_lys_alias": [
   "ceil"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "ceil:in0"
   ]
  ],
  "ruler_name": "r_ceil",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Ceil:in0"
   ]
  ],
  "src_ops_alias": [
   "Ceil"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "Ceil:out0"
  ],
  "param_map": {},
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Erf:out0",
    "erf:out0"
   ]
  ],
  "acu_lys_alias": [
   "erf"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "erf:in0"
   ]
  ],
  "ruler_name": "r_erf",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Erf:in0"
   ]
  ],
  "src_ops_alias": [
   "Erf"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "Erf:out0"
  ],
  "param_map": {},
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Floor:out0",
    "floor:out0"
   ]
  ],
  "acu_lys_alias": [
   "floor"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "floor:in0"
   ]
  ],
  "ruler_name": "r_floor",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Floor:in0"
   ]
  ],
  "src_ops_alias": [
   "Floor"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "Floor:out0"
  ],
  "param_map": {},
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Sqrt:out0",
    "sqrt:out0"
   ]
  ],
  "acu_lys_alias": [
   "sqrt"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "sqrt:in0"
   ]
  ],
  "ruler_name": "r_sqrt",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Sqrt:in0"
   ]
  ],
  "src_ops_alias": [
   "Sqrt"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "Sqrt:out0"
  ],
  "param_map": {},
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Log:out0",
    "log:out0"
   ]
  ],
  "acu_lys_alias": [
   "log"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "log:in0"
   ]
  ],
  "ruler_name": "r_log",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Log:in0"
   ]
  ],
  "src_ops_alias": [
   "Log"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "Log:out0"
  ],
  "param_map": {},
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Cast:out0",
    "cast:out0"
   ]
  ],
  "acu_lys_alias": [
   "cast"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "cast:in0"
   ]
  ],
  "ruler_name": "r_cast",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Cast:in0"
   ]
  ],
  "src_ops_alias": [
   "Cast"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "Cast:out0"
  ],
  "param_map": {
   "cast": {
    "out_data_type": [
     "STRING",
     "CODE",
     "self.cast_map_type(node['Cast'])"
    ],
    "in_data_type": [
     "STRING",
     "CODE",
     "self.cast_map_type(node['Cast'])"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Exp:out0",
    "exp:out0"
   ]
  ],
  "acu_lys_alias": [
   "exp"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "exp:in0"
   ]
  ],
  "ruler_name": "r_exp",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Exp:in0"
   ]
  ],
  "src_ops_alias": [
   "Exp"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "Exp:out0"
  ],
  "param_map": {},
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   4
  ],
  "src_acu_out_tensor_map": [
   [
    "Reshape_1:out0",
    "shuffle:out0"
   ]
  ],
  "acu_lys_alias": [
   "shuffle"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "shuffle:in0"
   ]
  ],
  "ruler_name": "r_rsp_tsp_rsp_2_shuffle_v1",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Reshape:in0"
   ]
  ],
  "src_ops_alias": [
   "Reshape",
   "Transpose",
   "Reshape_1"
  ],
  "blob_map": {},
  "pre_condition": "len(self.attr_pick(node['Reshape'], 'shape')) == 5 and len(self.attr_pick(node['Transpose'], 'perm')) == 5 and len(self.attr_pick(node['Reshape_1'], 'shape')) == 4 and self.attr_pick(node['Transpose'], 'perm') == [0, 2, 1, 3, 4]",
  "src_out_tensor": [
   "Reshape_1:out0"
  ],
  "param_map": {
   "shuffle": {
    "group_number": [
     "INT",
     "CODE",
     "self.attr_pick(node['Reshape'], 'shape')[1]"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Reshape:out0",
    "Transpose:in0"
   ],
   [
    "Transpose:out0",
    "Reshape_1:in0"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   5,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Reshape_1:out0",
    "shuffle:out0"
   ]
  ],
  "acu_lys_alias": [
   "shuffle"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "shuffle:in0"
   ]
  ],
  "ruler_name": "r_rsp_tsp_rsp_2_shuffle_v5",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Reshape:in0"
   ]
  ],
  "src_ops_alias": [
   "Reshape",
   "Transpose",
   "Reshape_1",
   "Constant_0"
  ],
  "blob_map": {},
  "pre_condition": "len(self.tensor_to_numpy(tensor['Reshape'].inputs[1])) == 5 and len(self.attr_pick(node['Transpose'], 'perm')) == 5 and len(self.tensor_to_numpy(tensor['Reshape_1'].inputs[1])) == 4 and self.attr_pick(node['Transpose'], 'perm') == [0, 2, 1, 3, 4]",
  "src_out_tensor": [
   "Reshape_1:out0"
  ],
  "param_map": {
   "shuffle": {
    "group_number": [
     "INT",
     "CODE",
     "self.tensor_to_numpy(tensor['Constant_0:out0'])[1]"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Reshape:out0",
    "Transpose:in0"
   ],
   [
    "Transpose:out0",
    "Reshape_1:in0"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Identity:out0",
    "noop:out0"
   ]
  ],
  "acu_lys_alias": [
   "noop"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "noop:in0"
   ]
  ],
  "ruler_name": "r_identity",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Identity:in0"
   ]
  ],
  "src_ops_alias": [
   "Identity"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "Identity:out0"
  ],
  "param_map": {},
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "ConstantFill:out0",
    "noop:out0"
   ]
  ],
  "acu_lys_alias": [
   "noop"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "noop:in0"
   ]
  ],
  "ruler_name": "r_constantfill",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "ConstantFill:in0"
   ]
  ],
  "src_ops_alias": [
   "ConstantFill"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "ConstantFill:out0"
  ],
  "param_map": {},
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   9
  ],
  "src_acu_out_tensor_map": [
   [
    "Slice:out0",
    "slice:out0"
   ]
  ],
  "acu_lys_alias": [
   "slice"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "slice:in0"
   ]
  ],
  "ruler_name": "r_slice",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Slice:in0"
   ]
  ],
  "src_ops_alias": [
   "Slice"
  ],
  "blob_map": {},
  "pre_condition": "self.attr_pick(node['Slice'], 'axes', None) == None",
  "src_out_tensor": [
   "Slice:out0"
  ],
  "param_map": {
   "slice": {
    "begin": [
     "INTS",
     "PYFUNC",
     [
      "def r_slice_get_begin(self, node, tensor):",
      "    in_shape = self.shape_pick(tensor['I:out0'])",
      "    starts = self.attr_pick(node['Slice'], 'starts', None)",
      "    axes = self.attr_pick(node['Slice'], 'axes', None)",
      "    begin = [0] * len(in_shape)",
      "    for i in range(len(axes)):",
      "        if starts[i] < 0:",
      "            starts[i] = in_shape[axes[i]] + starts[i]",
      "        begin[axes[i]] = starts[i]",
      "    return begin",
      ""
     ]
    ],
    "size": [
     "INTS",
     "PYFUNC",
     [
      "def r_slice_get_size(self, node, tensor):",
      "    starts = self.attr_pick(node['Slice'], 'starts', None)",
      "    ends = self.attr_pick(node['Slice'], 'ends', None)",
      "    axes = self.attr_pick(node['Slice'], 'axes', None)",
      "    in_shape = self.shape_pick(tensor['I:out0'])",
      "    out_shape = self.shape_pick(tensor['Slice:out0'])",
      "",
      "    import numpy as np",
      "    import copy",
      "    INT_MAX = np.iinfo(np.int64).max",
      "    in_shape = copy.deepcopy(in_shape)",
      "    ends = copy.deepcopy(ends)",
      "    size = copy.deepcopy(in_shape)",
      "    for i in range(len(axes)):",
      "        if starts[i] < 0:",
      "            starts[i] = in_shape[axes[i]] + starts[i]",
      "        if ends[i] == INT_MAX:",
      "            ends[i] = in_shape[axes[i]]",
      "        elif ends[i] < 0:",
      "            ends[i] = in_shape[axes[i]] + ends[i]",
      "        size[axes[i]] = ends[i] - starts[i]",
      "    return size",
      ""
     ]
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   9
  ],
  "src_acu_out_tensor_map": [
   [
    "Slice:out0",
    "slice:out0"
   ]
  ],
  "acu_lys_alias": [
   "slice"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "slice:in0"
   ]
  ],
  "ruler_name": "r_slice_axes",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Slice:in0"
   ]
  ],
  "src_ops_alias": [
   "Slice"
  ],
  "blob_map": {},
  "pre_condition": "self.attr_pick(node['Slice'], 'axes', None) != None",
  "src_out_tensor": [
   "Slice:out0"
  ],
  "param_map": {
   "slice": {
    "begin": [
     "INTS",
     "PYFUNC",
     [
      "def r_slice_get_begin(self, node, tensor):",
      "    in_shape = self.shape_pick(tensor['I:out0'])",
      "    starts = self.attr_pick(node['Slice'], 'starts', None)",
      "    axes = self.attr_pick(node['Slice'], 'axes', None)",
      "    begin = [0] * len(in_shape)",
      "    for i in range(len(axes)):",
      "        if starts[i] < 0:",
      "            starts[i] = in_shape[axes[i]] + starts[i]",
      "        begin[axes[i]] = starts[i]",
      "    return begin",
      ""
     ]
    ],
    "size": [
     "INTS",
     "PYFUNC",
     [
      "def r_slice_get_size(self, node, tensor):",
      "    starts = self.attr_pick(node['Slice'], 'starts', None)",
      "    ends = self.attr_pick(node['Slice'], 'ends', None)",
      "    axes = self.attr_pick(node['Slice'], 'axes', None)",
      "    in_shape = self.shape_pick(tensor['I:out0'])",
      "    out_shape = self.shape_pick(tensor['Slice:out0'])",
      "",
      "    import numpy as np",
      "    import copy",
      "    INT_MAX = np.iinfo(np.int64).max",
      "    in_shape = copy.deepcopy(in_shape)",
      "    ends = copy.deepcopy(ends)",
      "    size = copy.deepcopy(in_shape)",
      "    for i in range(len(axes)):",
      "        if starts[i] < 0:",
      "            starts[i] = in_shape[axes[i]] + starts[i]",
      "        if ends[i] == INT_MAX:",
      "            ends[i] = in_shape[axes[i]]",
      "        elif ends[i] < 0:",
      "            ends[i] = in_shape[axes[i]] + ends[i]",
      "        size[axes[i]] = ends[i] - starts[i]",
      "    return size",
      ""
     ]
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   10,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Slice:out0",
    "slice:out0"
   ]
  ],
  "acu_lys_alias": [
   "slice"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "slice:in0"
   ]
  ],
  "ruler_name": "r_slice_ex",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "Slice:in0"
   ]
  ],
  "src_ops_alias": [
   "Slice",
   "Constant",
   "Constant_1"
  ],
  "blob_map": {
   "slice": {}
  },
  "pre_condition": null,
  "src_out_tensor": [
   "Slice:out0"
  ],
  "param_map": {
   "slice": {
    "begin": [
     "INTS",
     "CODE",
     "self.slice_ex_begin(node['Slice'], self.shape_pick(tensor['I_0:out0']), tensor['Constant:out0'])"
    ],
    "size": [
     "INTS",
     "CODE",
     "self.slice_ex_size(node['Slice'], self.shape_pick(tensor['I_0:out0']), tensor['Constant:out0'], tensor['Constant_1:out0'])"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant:out0",
    "Slice:in1"
   ],
   [
    "Constant_1:out0",
    "Slice:in2"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Slice:out0",
    "slice:out0"
   ]
  ],
  "acu_lys_alias": [
   "slice"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "slice:in0"
   ]
  ],
  "ruler_name": "r_slice_2",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "Slice:in0"
   ]
  ],
  "src_ops_alias": [
   "Slice",
   "Constant",
   "Constant_1",
   "Constant_2",
   "Constant_3"
  ],
  "blob_map": {
   "slice": {}
  },
  "pre_condition": [
   "__rule_func_additional_args = {\"steps_tensor\": \"Constant_3:out0\"}",
   "def r_slice_pre_cond(self, node, tensor, steps_tensor):",
   "    steps = self.tensor_to_numpy(tensor[steps_tensor]).tolist()",
   "    for step in steps:",
   "        if step != 1:",
   "            return False",
   "    return True",
   ""
  ],
  "src_out_tensor": [
   "Slice:out0"
  ],
  "param_map": {
   "slice": {
    "begin": [
     "INTS",
     "CODE",
     "self.slice_ex_begin(node['Slice'], self.shape_pick(tensor['I_0:out0']), tensor['Constant:out0'], tensor['Constant_2:out0'])"
    ],
    "size": [
     "INTS",
     "CODE",
     "self.slice_ex_size(node['Slice'], self.shape_pick(tensor['I_0:out0']), tensor['Constant:out0'], tensor['Constant_1:out0'], tensor['Constant_2:out0'])"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant:out0",
    "Slice:in1"
   ],
   [
    "Constant_1:out0",
    "Slice:in2"
   ],
   [
    "Constant_2:out0",
    "Slice:in3"
   ],
   [
    "Constant_3:out0",
    "Slice:in4"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Slice:out0",
    "slice:out0"
   ]
  ],
  "acu_lys_alias": [
   "slice"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "slice:in0"
   ]
  ],
  "ruler_name": "r_slice_3",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "Slice:in0"
   ]
  ],
  "src_ops_alias": [
   "Slice",
   "Constant",
   "Constant_1",
   "Constant_2"
  ],
  "blob_map": {
   "slice": {}
  },
  "pre_condition": null,
  "src_out_tensor": [
   "Slice:out0"
  ],
  "param_map": {
   "slice": {
    "begin": [
     "INTS",
     "CODE",
     "self.slice_ex_begin(node['Slice'], self.shape_pick(tensor['I_0:out0']), tensor['Constant:out0'], tensor['Constant_2:out0'])"
    ],
    "size": [
     "INTS",
     "CODE",
     "self.slice_ex_size(node['Slice'], self.shape_pick(tensor['I_0:out0']), tensor['Constant:out0'], tensor['Constant_1:out0'], tensor['Constant_2:out0'])"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant:out0",
    "Slice:in1"
   ],
   [
    "Constant_1:out0",
    "Slice:in2"
   ],
   [
    "Constant_2:out0",
    "Slice:in3"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Slice:out0",
    "stridedslice:out0"
   ]
  ],
  "acu_lys_alias": [
   "stridedslice"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "stridedslice:in0"
   ]
  ],
  "ruler_name": "r_slice_to_stride_slice",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "Slice:in0"
   ]
  ],
  "src_ops_alias": [
   "Slice",
   "Constant",
   "Constant_1",
   "Constant_2",
   "Constant_3"
  ],
  "blob_map": {
   "stridedslice": {}
  },
  "pre_condition": null,
  "src_out_tensor": [
   "Slice:out0"
  ],
  "param_map": {
   "stridedslice": {
    "slice_strides": [
     "INTS",
     "CODE",
     "self.stride_slice_strides(node['Slice'], self.shape_pick(tensor['I_0:out0']), tensor['Constant_3:out0'], tensor['Constant_2:out0'])"
    ],
    "slice_end": [
     "INTS",
     "CODE",
     "self.stride_slice_end(node['Slice'], self.shape_pick(tensor['I_0:out0']), tensor['Constant_1:out0'], tensor['Constant_2:out0'])"
    ],
    "slice_begin": [
     "INTS",
     "CODE",
     "self.slice_ex_begin(node['Slice'], self.shape_pick(tensor['I_0:out0']), tensor['Constant:out0'], tensor['Constant_2:out0'])"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant:out0",
    "Slice:in1"
   ],
   [
    "Constant_1:out0",
    "Slice:in2"
   ],
   [
    "Constant_2:out0",
    "Slice:in3"
   ],
   [
    "Constant_3:out0",
    "Slice:in4"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   8
  ],
  "src_acu_out_tensor_map": [
   [
    "Upsample:out0",
    "image_resize:out0"
   ]
  ],
  "acu_lys_alias": [
   "image_resize"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "image_resize:in0"
   ]
  ],
  "ruler_name": "upsample_l7_to_resize",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Upsample:in0"
   ]
  ],
  "src_ops_alias": [
   "Upsample"
  ],
  "blob_map": {
   "image_resize": {}
  },
  "pre_condition": null,
  "src_out_tensor": [
   "Upsample:out0"
  ],
  "param_map": {
   "image_resize": {
    "type": [
     "STRING",
     "CODE",
     "self.attr_pick(node['Upsample'], 'mode')"
    ],
    "align_corners": [
     "BOOL",
     "VALUE",
     false
    ],
    "new_size": [
     "ORIGIN",
     "CODE",
     "self.shape_pick(tensor['Upsample:out0'])[2:]"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   9,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Upsample:out0",
    "image_resize:out0"
   ]
  ],
  "acu_lys_alias": [
   "image_resize"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "image_resize:in0"
   ]
  ],
  "ruler_name": "upsample_l9_to_resize",
  "priority_tip": 11,
  "src_in_anchor": [
   [
    "I:out0",
    "Upsample:in0"
   ]
  ],
  "src_ops_alias": [
   "Upsample",
   "Constant"
  ],
  "blob_map": {
   "image_resize": {}
  },
  "pre_condition": null,
  "src_out_tensor": [
   "Upsample:out0"
  ],
  "param_map": {
   "image_resize": {
    "type": [
     "STRING",
     "CODE",
     "'bilinear' if self.attr_pick(node['Upsample'], 'mode') == 'linear' else self.attr_pick(node['Upsample'], 'mode')"
    ],
    "align_corners": [
     "BOOL",
     "VALUE",
     false
    ],
    "new_size": [
     "ORIGIN",
     "CODE",
     "self.shape_pick(tensor['Upsample:out0'])[2:]"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant:out0",
    "Upsample:in1"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   9,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Upsample:out0",
    "image_resize:out0"
   ]
  ],
  "acu_lys_alias": [
   "image_resize"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "image_resize:in0"
   ]
  ],
  "ruler_name": "r_upsample_l9_scale_to_resize",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Upsample:in0"
   ],
   [
    "I_1:out0",
    "Upsample:in1"
   ]
  ],
  "src_ops_alias": [
   "Upsample"
  ],
  "blob_map": {
   "image_resize": {}
  },
  "pre_condition": null,
  "src_out_tensor": [
   "Upsample:out0"
  ],
  "param_map": {
   "image_resize": {
    "type": [
     "STRING",
     "CODE",
     "'bilinear' if self.attr_pick(node['Upsample'], 'mode') == 'linear' else self.attr_pick(node['Upsample'], 'mode')"
    ],
    "align_corners": [
     "BOOL",
     "VALUE",
     false
    ],
    "new_size": [
     "ORIGIN",
     "CODE",
     "self.shape_pick(tensor['Upsample:out0'])[2:]"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   0,
   10
  ],
  "src_acu_out_tensor_map": [
   [
    "Resize:out0",
    "image_resize:out0"
   ]
  ],
  "acu_lys_alias": [
   "image_resize"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "image_resize:in0"
   ]
  ],
  "ruler_name": "r_resize_10",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Resize:in0"
   ]
  ],
  "src_ops_alias": [
   "Resize",
   "Constant"
  ],
  "blob_map": {},
  "pre_condition": [
   "def r_resize_10_check(self, node, tensor):",
   "    in_shape = self.shape_pick(tensor[\"I:out0\"])",
   "    out_shape = self.shape_pick(tensor[\"Resize:out0\"])",
   "",
   "    # acuity only support 3D or 4D resize",
   "    if len(in_shape) < 2 or len(in_shape) > 4:",
   "        return False",
   "    # acuity only support resize width or height",
   "    if in_shape[0] != out_shape[0] or in_shape[1] != out_shape[1]:",
   "        return False",
   "",
   "    return True",
   ""
  ],
  "src_out_tensor": [
   "Resize:out0"
  ],
  "param_map": {
   "image_resize": {
    "type": [
     "STRING",
     "PYFUNC",
     [
      "def r_resize_get_type(self, node, tensor):",
      "    mode = self.attr_pick(node['Resize'], 'mode', 'nearest').lower()",
      "    _mode_map = {",
      "        \"nearest\": \"nearest\",",
      "        \"linear\": \"bilinear\",",
      "        \"cubic\": \"bicubic\"",
      "    }",
      "",
      "    _maped_mode = \"nearest\"",
      "    if mode in _mode_map.keys():",
      "        _maped_mode = _mode_map[mode]",
      "    return _maped_mode",
      ""
     ]
    ],
    "align_corners": [
     "BOOL",
     "VALUE",
     false
    ],
    "half_pixel": [
     "BOOL",
     "VALUE",
     false
    ],
    "new_size": [
     "INTS",
     "PYFUNC",
     [
      "def r_resize_get_new_size(self, node, tensor):",
      "    out_shape = self.shape_pick(tensor[\"Resize:out0\"])",
      "    new_size = out_shape[2:] # [batch, channel, height, width] or [batch, channel, width]",
      "    return new_size",
      ""
     ]
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant:out0",
    "Resize:in1"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   11,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Resize:out0",
    "image_resize:out0"
   ]
  ],
  "acu_lys_alias": [
   "image_resize"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "image_resize:in0"
   ]
  ],
  "ruler_name": "r_resize",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Resize:in0"
   ]
  ],
  "src_ops_alias": [
   "Resize",
   "Constant",
   "Constant_1"
  ],
  "blob_map": {},
  "pre_condition": [
   "def r_resize_check(self, node, tensor):",
   "    in_shape = self.shape_pick(tensor[\"I:out0\"])",
   "    out_shape = self.shape_pick(tensor[\"Resize:out0\"])",
   "",
   "    # acuity only support 3D or 4D resize",
   "    if len(in_shape) < 2 or len(in_shape) > 4:",
   "        return False",
   "    # acuity only support resize width or height",
   "    if in_shape[0] != out_shape[0] or in_shape[1] != out_shape[1]:",
   "        return False",
   "",
   "    unsuppored_trans_mode = [",
   "        #'pytorch_half_pixel',",
   "        #for pytorch_half_pixel, we assue that length_resized will always > 1,",
   "        #in this condition, it equals to 'half_pixel',",
   "        #but if length_resized == 1, there will be some precision issue",
   "        'tf_half_piexl_for_nn',",
   "        'tf_crop_and_resize'",
   "    ]",
   "    trans_mode = self.attr_pick(node['Resize'], 'coordinate_transformation_mode', 'half_pixel')",
   "    if trans_mode in unsuppored_trans_mode:",
   "        return False",
   "",
   "    mode = self.attr_pick(node['Resize'], 'mode', 'nearest')",
   "    nearest_mode = self.attr_pick(node['Resize'], 'nearest_mode', 'round_prefer_floor')",
   "    if mode == 'nearest' and 'ceil' in nearest_mode:",
   "        return False",
   "",
   "    # pytorch coeff_a is -0.75",
   "    # tf coeff_a is -0.5, we only support this coeff_a",
   "    coeff_a = self.attr_pick(node['Resize'], 'cubic_coeff_a', -0.75)",
   "    if mode == 'cubic' and coeff_a != -0.5:",
   "        return False",
   "",
   "    return True",
   ""
  ],
  "src_out_tensor": [
   "Resize:out0"
  ],
  "param_map": {
   "image_resize": {
    "type": [
     "STRING",
     "PYFUNC",
     [
      "def r_resize_get_type(self, node, tensor):",
      "    mode = self.attr_pick(node['Resize'], 'mode', 'nearest').lower()",
      "    _mode_map = {",
      "        \"nearest\": \"nearest\",",
      "        \"linear\": \"bilinear\",",
      "        \"cubic\": \"bicubic\"",
      "    }",
      "",
      "    _maped_mode = \"nearest\"",
      "    if mode in _mode_map.keys():",
      "        _maped_mode = _mode_map[mode]",
      "    return _maped_mode",
      ""
     ]
    ],
    "align_corners": [
     "BOOL",
     "PYFUNC",
     [
      "def r_resize_get_align_corners(self, node, tensor):",
      "    trans_mode = self.attr_pick(node['Resize'], 'coordinate_transformation_mode', 'half_pixel')",
      "    if trans_mode == 'align_corners':",
      "        return True",
      "    return False",
      ""
     ]
    ],
    "half_pixel": [
     "BOOL",
     "PYFUNC",
     [
      "def r_resize_get_half_pixel(self, node, tensor):",
      "    trans_mode = self.attr_pick(node['Resize'], 'coordinate_transformation_mode', 'half_pixel')",
      "    # for pytorch_half_pixel, we assue that length_resized will always > 1,",
      "    # in this condition, it equals to 'half_pixel',",
      "    # but if length_resized == 1, there will be some precision issue",
      "    if trans_mode in ['half_pixel', 'pytorch_half_pixel']:",
      "        return True",
      "    return False",
      ""
     ]
    ],
    "new_size": [
     "INTS",
     "PYFUNC",
     [
      "def r_resize_get_new_size(self, node, tensor):",
      "    out_shape = self.shape_pick(tensor[\"Resize:out0\"])",
      "    new_size = out_shape[2:] # [batch, channel, height, width] or [batch, channel, width]",
      "    return new_size",
      ""
     ]
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant:out0",
    "Resize:in1"
   ],
   [
    "Constant_1:out0",
    "Resize:in2"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   11,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Resize:out0",
    "image_resize:out0"
   ]
  ],
  "acu_lys_alias": [
   "image_resize"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "image_resize:in0"
   ]
  ],
  "ruler_name": "r_resize_size",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Resize:in0"
   ]
  ],
  "src_ops_alias": [
   "Resize",
   "Constant",
   "Constant_1",
   "Constant_2"
  ],
  "blob_map": {},
  "pre_condition": [
   "def r_resize_check(self, node, tensor):",
   "    in_shape = self.shape_pick(tensor[\"I:out0\"])",
   "    out_shape = self.shape_pick(tensor[\"Resize:out0\"])",
   "",
   "    # acuity only support 3D or 4D resize",
   "    if len(in_shape) < 2 or len(in_shape) > 4:",
   "        return False",
   "    # acuity only support resize width or height",
   "    if in_shape[0] != out_shape[0] or in_shape[1] != out_shape[1]:",
   "        return False",
   "",
   "    unsuppored_trans_mode = [",
   "        #'pytorch_half_pixel',",
   "        #for pytorch_half_pixel, we assue that length_resized will always > 1,",
   "        #in this condition, it equals to 'half_pixel',",
   "        #but if length_resized == 1, there will be some precision issue",
   "        'tf_half_piexl_for_nn',",
   "        'tf_crop_and_resize'",
   "    ]",
   "    trans_mode = self.attr_pick(node['Resize'], 'coordinate_transformation_mode', 'half_pixel')",
   "    if trans_mode in unsuppored_trans_mode:",
   "        return False",
   "",
   "    mode = self.attr_pick(node['Resize'], 'mode', 'nearest')",
   "    nearest_mode = self.attr_pick(node['Resize'], 'nearest_mode', 'round_prefer_floor')",
   "    if mode == 'nearest' and 'ceil' in nearest_mode:",
   "        return False",
   "",
   "    # pytorch coeff_a is -0.75",
   "    # tf coeff_a is -0.5, we only support this coeff_a",
   "    coeff_a = self.attr_pick(node['Resize'], 'cubic_coeff_a', -0.75)",
   "    if mode == 'cubic' and coeff_a != -0.5:",
   "        return False",
   "",
   "    return True",
   ""
  ],
  "src_out_tensor": [
   "Resize:out0"
  ],
  "param_map": {
   "image_resize": {
    "type": [
     "STRING",
     "PYFUNC",
     [
      "def r_resize_get_type(self, node, tensor):",
      "    mode = self.attr_pick(node['Resize'], 'mode', 'nearest').lower()",
      "    _mode_map = {",
      "        \"nearest\": \"nearest\",",
      "        \"linear\": \"bilinear\",",
      "        \"cubic\": \"bicubic\"",
      "    }",
      "",
      "    _maped_mode = \"nearest\"",
      "    if mode in _mode_map.keys():",
      "        _maped_mode = _mode_map[mode]",
      "    return _maped_mode",
      ""
     ]
    ],
    "align_corners": [
     "BOOL",
     "PYFUNC",
     [
      "def r_resize_get_align_corners(self, node, tensor):",
      "    trans_mode = self.attr_pick(node['Resize'], 'coordinate_transformation_mode', 'half_pixel')",
      "    if trans_mode == 'align_corners':",
      "        return True",
      "    return False",
      ""
     ]
    ],
    "half_pixel": [
     "BOOL",
     "PYFUNC",
     [
      "def r_resize_get_half_pixel(self, node, tensor):",
      "    trans_mode = self.attr_pick(node['Resize'], 'coordinate_transformation_mode', 'half_pixel')",
      "    # for pytorch_half_pixel, we assue that length_resized will always > 1,",
      "    # in this condition, it equals to 'half_pixel',",
      "    # but if length_resized == 1, there will be some precision issue",
      "    if trans_mode in ['half_pixel', 'pytorch_half_pixel']:",
      "        return True",
      "    return False",
      ""
     ]
    ],
    "new_size": [
     "INTS",
     "PYFUNC",
     [
      "def r_resize_get_new_size(self, node, tensor):",
      "    out_shape = self.shape_pick(tensor[\"Resize:out0\"])",
      "    new_size = out_shape[2:] # [batch, channel, height, width] or [batch, channel, width]",
      "    return new_size",
      ""
     ]
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant:out0",
    "Resize:in1"
   ],
   [
    "Constant_1:out0",
    "Resize:in2"
   ],
   [
    "Constant_2:out0",
    "Resize:in3"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   11,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Resize:out0",
    "image_resize:out0"
   ]
  ],
  "acu_lys_alias": [
   "image_resize"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "image_resize:in0"
   ]
  ],
  "ruler_name": "r_resize_i0_constant_frozentablei1",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Resize:in0"
   ],
   [
    "I_1:out0",
    "Resize:in3"
   ]
  ],
  "src_ops_alias": [
   "Resize",
   "Constant"
  ],
  "blob_map": {},
  "pre_condition": [
   "def r_resize_check(self, node, tensor):",
   "    in_shape = self.shape_pick(tensor[\"I:out0\"])",
   "    out_shape = self.shape_pick(tensor[\"Resize:out0\"])",
   "",
   "    # acuity only support 3D or 4D resize",
   "    if len(in_shape) < 2 or len(in_shape) > 4:",
   "        return False",
   "    # acuity only support resize width or height",
   "    if in_shape[0] != out_shape[0] or in_shape[1] != out_shape[1]:",
   "        return False",
   "",
   "    unsuppored_trans_mode = [",
   "        #'pytorch_half_pixel',",
   "        #for pytorch_half_pixel, we assue that length_resized will always > 1,",
   "        #in this condition, it equals to 'half_pixel',",
   "        #but if length_resized == 1, there will be some precision issue",
   "        'tf_half_piexl_for_nn',",
   "        'tf_crop_and_resize'",
   "    ]",
   "    trans_mode = self.attr_pick(node['Resize'], 'coordinate_transformation_mode', 'half_pixel')",
   "    if trans_mode in unsuppored_trans_mode:",
   "        return False",
   "",
   "    mode = self.attr_pick(node['Resize'], 'mode', 'nearest')",
   "    nearest_mode = self.attr_pick(node['Resize'], 'nearest_mode', 'round_prefer_floor')",
   "    if mode == 'nearest' and 'ceil' in nearest_mode:",
   "        return False",
   "",
   "    # pytorch coeff_a is -0.75",
   "    # tf coeff_a is -0.5, we only support this coeff_a",
   "    coeff_a = self.attr_pick(node['Resize'], 'cubic_coeff_a', -0.75)",
   "    if mode == 'cubic' and coeff_a != -0.5:",
   "        return False",
   "",
   "    return True",
   ""
  ],
  "src_out_tensor": [
   "Resize:out0"
  ],
  "param_map": {
   "image_resize": {
    "type": [
     "STRING",
     "PYFUNC",
     [
      "def r_resize_get_type(self, node, tensor):",
      "    mode = self.attr_pick(node['Resize'], 'mode', 'nearest').lower()",
      "    _mode_map = {",
      "        \"nearest\": \"nearest\",",
      "        \"linear\": \"bilinear\",",
      "        \"cubic\": \"bicubic\"",
      "    }",
      "",
      "    _maped_mode = \"nearest\"",
      "    if mode in _mode_map.keys():",
      "        _maped_mode = _mode_map[mode]",
      "    return _maped_mode",
      ""
     ]
    ],
    "align_corners": [
     "BOOL",
     "PYFUNC",
     [
      "def r_resize_get_align_corners(self, node, tensor):",
      "    trans_mode = self.attr_pick(node['Resize'], 'coordinate_transformation_mode', 'half_pixel')",
      "    if trans_mode == 'align_corners':",
      "        return True",
      "    return False",
      ""
     ]
    ],
    "half_pixel": [
     "BOOL",
     "PYFUNC",
     [
      "def r_resize_get_half_pixel(self, node, tensor):",
      "    trans_mode = self.attr_pick(node['Resize'], 'coordinate_transformation_mode', 'half_pixel')",
      "    # for pytorch_half_pixel, we assue that length_resized will always > 1,",
      "    # in this condition, it equals to 'half_pixel',",
      "    # but if length_resized == 1, there will be some precision issue",
      "    if trans_mode in ['half_pixel', 'pytorch_half_pixel']:",
      "        return True",
      "    return False",
      ""
     ]
    ],
    "new_size": [
     "INTS",
     "PYFUNC",
     [
      "def r_resize_get_new_size(self, node, tensor):",
      "    out_shape = self.shape_pick(tensor[\"Resize:out0\"])",
      "    new_size = out_shape[2:] # [batch, channel, height, width] or [batch, channel, width]",
      "    return new_size",
      ""
     ]
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant:out0",
    "Resize:in1"
   ],
   [
    "Constant:out0",
    "Resize:in2"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   11,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Resize:out0",
    "image_resize:out0"
   ]
  ],
  "acu_lys_alias": [
   "image_resize"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "image_resize:in0"
   ]
  ],
  "ruler_name": "r_resize_i0_constant0_constant1",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Resize:in0"
   ]
  ],
  "src_ops_alias": [
   "Resize",
   "Constant",
   "Constant_1"
  ],
  "blob_map": {
   "image_resize": {}
  },
  "pre_condition": [
   "def r_resize_check(self, node, tensor):",
   "    in_shape = self.shape_pick(tensor[\"I:out0\"])",
   "    out_shape = self.shape_pick(tensor[\"Resize:out0\"])",
   "",
   "    # acuity only support 3D or 4D resize",
   "    if len(in_shape) < 2 or len(in_shape) > 4:",
   "        return False",
   "    # acuity only support resize width or height",
   "    if in_shape[0] != out_shape[0] or in_shape[1] != out_shape[1]:",
   "        return False",
   "",
   "    unsuppored_trans_mode = [",
   "        #'pytorch_half_pixel',",
   "        #for pytorch_half_pixel, we assue that length_resized will always > 1,",
   "        #in this condition, it equals to 'half_pixel',",
   "        #but if length_resized == 1, there will be some precision issue",
   "        'tf_half_piexl_for_nn',",
   "        'tf_crop_and_resize'",
   "    ]",
   "    trans_mode = self.attr_pick(node['Resize'], 'coordinate_transformation_mode', 'half_pixel')",
   "    if trans_mode in unsuppored_trans_mode:",
   "        return False",
   "",
   "    mode = self.attr_pick(node['Resize'], 'mode', 'nearest')",
   "    nearest_mode = self.attr_pick(node['Resize'], 'nearest_mode', 'round_prefer_floor')",
   "    if mode == 'nearest' and 'ceil' in nearest_mode:",
   "        return False",
   "",
   "    # pytorch coeff_a is -0.75",
   "    # tf coeff_a is -0.5, we only support this coeff_a",
   "    coeff_a = self.attr_pick(node['Resize'], 'cubic_coeff_a', -0.75)",
   "    if mode == 'cubic' and coeff_a != -0.5:",
   "        return False",
   "",
   "    return True",
   ""
  ],
  "src_out_tensor": [
   "Resize:out0"
  ],
  "param_map": {
   "image_resize": {
    "type": [
     "STRING",
     "PYFUNC",
     [
      "def r_resize_get_type(self, node, tensor):",
      "    mode = self.attr_pick(node['Resize'], 'mode', 'nearest').lower()",
      "    _mode_map = {",
      "        \"nearest\": \"nearest\",",
      "        \"linear\": \"bilinear\",",
      "        \"cubic\": \"bicubic\"",
      "    }",
      "",
      "    _maped_mode = \"nearest\"",
      "    if mode in _mode_map.keys():",
      "        _maped_mode = _mode_map[mode]",
      "    return _maped_mode",
      ""
     ]
    ],
    "align_corners": [
     "BOOL",
     "PYFUNC",
     [
      "def r_resize_get_align_corners(self, node, tensor):",
      "    trans_mode = self.attr_pick(node['Resize'], 'coordinate_transformation_mode', 'half_pixel')",
      "    if trans_mode == 'align_corners':",
      "        return True",
      "    return False",
      ""
     ]
    ],
    "half_pixel": [
     "BOOL",
     "PYFUNC",
     [
      "def r_resize_get_half_pixel(self, node, tensor):",
      "    trans_mode = self.attr_pick(node['Resize'], 'coordinate_transformation_mode', 'half_pixel')",
      "    # for pytorch_half_pixel, we assue that length_resized will always > 1,",
      "    # in this condition, it equals to 'half_pixel',",
      "    # but if length_resized == 1, there will be some precision issue",
      "    if trans_mode in ['half_pixel', 'pytorch_half_pixel']:",
      "        return True",
      "    return False",
      ""
     ]
    ],
    "new_size": [
     "INTS",
     "PYFUNC",
     [
      "def r_resize_get_new_size(self, node, tensor):",
      "    out_shape = self.shape_pick(tensor[\"Resize:out0\"])",
      "    new_size = out_shape[2:] # [batch, channel, height, width] or [batch, channel, width]",
      "    return new_size",
      ""
     ]
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant:out0",
    "Resize:in1"
   ],
   [
    "Constant:out0",
    "Resize:in2"
   ],
   [
    "Constant_1:out0",
    "Resize:in3"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   11,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Resize:out0",
    "image_resize:out0"
   ]
  ],
  "acu_lys_alias": [
   "image_resize"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "image_resize:in0"
   ]
  ],
  "ruler_name": "r_resize_i_frozentablei1",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Resize:in0"
   ],
   [
    "I_1:out0",
    "Resize:in3"
   ]
  ],
  "src_ops_alias": [
   "Resize"
  ],
  "blob_map": {},
  "pre_condition": [
   "def r_resize_check(self, node, tensor):",
   "    in_shape = self.shape_pick(tensor[\"I:out0\"])",
   "    out_shape = self.shape_pick(tensor[\"Resize:out0\"])",
   "",
   "    # acuity only support 3D or 4D resize",
   "    if len(in_shape) < 2 or len(in_shape) > 4:",
   "        return False",
   "    # acuity only support resize width or height",
   "    if in_shape[0] != out_shape[0] or in_shape[1] != out_shape[1]:",
   "        return False",
   "",
   "    unsuppored_trans_mode = [",
   "        #'pytorch_half_pixel',",
   "        #for pytorch_half_pixel, we assue that length_resized will always > 1,",
   "        #in this condition, it equals to 'half_pixel',",
   "        #but if length_resized == 1, there will be some precision issue",
   "        'tf_half_piexl_for_nn',",
   "        'tf_crop_and_resize'",
   "    ]",
   "    trans_mode = self.attr_pick(node['Resize'], 'coordinate_transformation_mode', 'half_pixel')",
   "    if trans_mode in unsuppored_trans_mode:",
   "        return False",
   "",
   "    mode = self.attr_pick(node['Resize'], 'mode', 'nearest')",
   "    nearest_mode = self.attr_pick(node['Resize'], 'nearest_mode', 'round_prefer_floor')",
   "    if mode == 'nearest' and 'ceil' in nearest_mode:",
   "        return False",
   "",
   "    # pytorch coeff_a is -0.75",
   "    # tf coeff_a is -0.5, we only support this coeff_a",
   "    coeff_a = self.attr_pick(node['Resize'], 'cubic_coeff_a', -0.75)",
   "    if mode == 'cubic' and coeff_a != -0.5:",
   "        return False",
   "",
   "    return True",
   ""
  ],
  "src_out_tensor": [
   "Resize:out0"
  ],
  "param_map": {
   "image_resize": {
    "type": [
     "STRING",
     "PYFUNC",
     [
      "def r_resize_get_type(self, node, tensor):",
      "    mode = self.attr_pick(node['Resize'], 'mode', 'nearest').lower()",
      "    _mode_map = {",
      "        \"nearest\": \"nearest\",",
      "        \"linear\": \"bilinear\",",
      "        \"cubic\": \"bicubic\"",
      "    }",
      "",
      "    _maped_mode = \"nearest\"",
      "    if mode in _mode_map.keys():",
      "        _maped_mode = _mode_map[mode]",
      "    return _maped_mode",
      ""
     ]
    ],
    "align_corners": [
     "BOOL",
     "PYFUNC",
     [
      "def r_resize_get_align_corners(self, node, tensor):",
      "    trans_mode = self.attr_pick(node['Resize'], 'coordinate_transformation_mode', 'half_pixel')",
      "    if trans_mode == 'align_corners':",
      "        return True",
      "    return False",
      ""
     ]
    ],
    "half_pixel": [
     "BOOL",
     "PYFUNC",
     [
      "def r_resize_get_half_pixel(self, node, tensor):",
      "    trans_mode = self.attr_pick(node['Resize'], 'coordinate_transformation_mode', 'half_pixel')",
      "    # for pytorch_half_pixel, we assue that length_resized will always > 1,",
      "    # in this condition, it equals to 'half_pixel',",
      "    # but if length_resized == 1, there will be some precision issue",
      "    if trans_mode in ['half_pixel', 'pytorch_half_pixel']:",
      "        return True",
      "    return False",
      ""
     ]
    ],
    "new_size": [
     "INTS",
     "PYFUNC",
     [
      "def r_resize_get_new_size(self, node, tensor):",
      "    out_shape = self.shape_pick(tensor[\"Resize:out0\"])",
      "    new_size = out_shape[2:] # [batch, channel, height, width] or [batch, channel, width]",
      "    return new_size",
      ""
     ]
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   11,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Resize:out0",
    "image_resize:out0"
   ]
  ],
  "acu_lys_alias": [
   "image_resize"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "image_resize:in0"
   ]
  ],
  "ruler_name": "r_resize_size",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Resize:in0"
   ],
   [
    "I_1:out0",
    "Resize:in1"
   ],
   [
    "I_2:out0",
    "Resize:in2"
   ],
   [
    "I_3:out0",
    "Resize:in3"
   ]
  ],
  "src_ops_alias": [
   "Resize"
  ],
  "blob_map": {},
  "pre_condition": [
   "def r_resize_check(self, node, tensor):",
   "    in_shape = self.shape_pick(tensor[\"I:out0\"])",
   "    out_shape = self.shape_pick(tensor[\"Resize:out0\"])",
   "",
   "    # acuity only support 3D or 4D resize",
   "    if len(in_shape) < 2 or len(in_shape) > 4:",
   "        return False",
   "    # acuity only support resize width or height",
   "    if in_shape[0] != out_shape[0] or in_shape[1] != out_shape[1]:",
   "        return False",
   "",
   "    unsuppored_trans_mode = [",
   "        #'pytorch_half_pixel',",
   "        #for pytorch_half_pixel, we assue that length_resized will always > 1,",
   "        #in this condition, it equals to 'half_pixel',",
   "        #but if length_resized == 1, there will be some precision issue",
   "        'tf_half_piexl_for_nn',",
   "        'tf_crop_and_resize'",
   "    ]",
   "    trans_mode = self.attr_pick(node['Resize'], 'coordinate_transformation_mode', 'half_pixel')",
   "    if trans_mode in unsuppored_trans_mode:",
   "        return False",
   "",
   "    mode = self.attr_pick(node['Resize'], 'mode', 'nearest')",
   "    nearest_mode = self.attr_pick(node['Resize'], 'nearest_mode', 'round_prefer_floor')",
   "    if mode == 'nearest' and 'ceil' in nearest_mode:",
   "        return False",
   "",
   "    # pytorch coeff_a is -0.75",
   "    # tf coeff_a is -0.5, we only support this coeff_a",
   "    coeff_a = self.attr_pick(node['Resize'], 'cubic_coeff_a', -0.75)",
   "    if mode == 'cubic' and coeff_a != -0.5:",
   "        return False",
   "",
   "    return True",
   ""
  ],
  "src_out_tensor": [
   "Resize:out0"
  ],
  "param_map": {
   "image_resize": {
    "type": [
     "STRING",
     "PYFUNC",
     [
      "def r_resize_get_type(self, node, tensor):",
      "    mode = self.attr_pick(node['Resize'], 'mode', 'nearest').lower()",
      "    _mode_map = {",
      "        \"nearest\": \"nearest\",",
      "        \"linear\": \"bilinear\",",
      "        \"cubic\": \"bicubic\"",
      "    }",
      "",
      "    _maped_mode = \"nearest\"",
      "    if mode in _mode_map.keys():",
      "        _maped_mode = _mode_map[mode]",
      "    return _maped_mode",
      ""
     ]
    ],
    "align_corners": [
     "BOOL",
     "PYFUNC",
     [
      "def r_resize_get_align_corners(self, node, tensor):",
      "    trans_mode = self.attr_pick(node['Resize'], 'coordinate_transformation_mode', 'half_pixel')",
      "    if trans_mode == 'align_corners':",
      "        return True",
      "    return False",
      ""
     ]
    ],
    "half_pixel": [
     "BOOL",
     "PYFUNC",
     [
      "def r_resize_get_half_pixel(self, node, tensor):",
      "    trans_mode = self.attr_pick(node['Resize'], 'coordinate_transformation_mode', 'half_pixel')",
      "    # for pytorch_half_pixel, we assue that length_resized will always > 1,",
      "    # in this condition, it equals to 'half_pixel',",
      "    # but if length_resized == 1, there will be some precision issue",
      "    if trans_mode in ['half_pixel', 'pytorch_half_pixel']:",
      "        return True",
      "    return False",
      ""
     ]
    ],
    "new_size": [
     "INTS",
     "PYFUNC",
     [
      "def r_resize_get_new_size(self, node, tensor):",
      "    out_shape = self.shape_pick(tensor[\"Resize:out0\"])",
      "    new_size = out_shape[2:] # [batch, channel, height, width] or [batch, channel, width]",
      "    return new_size",
      ""
     ]
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   13,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Resize:out0",
    "image_resize:out0"
   ]
  ],
  "acu_lys_alias": [
   "image_resize"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "image_resize:in0"
   ]
  ],
  "ruler_name": "r_resize_i0_scales",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Resize:in0"
   ]
  ],
  "src_ops_alias": [
   "Resize",
   "Constant"
  ],
  "blob_map": {},
  "pre_condition": [
   "def r_resize_check(self, node, tensor):",
   "    in_shape = self.shape_pick(tensor[\"I:out0\"])",
   "    out_shape = self.shape_pick(tensor[\"Resize:out0\"])",
   "",
   "    # acuity only support 3D or 4D resize",
   "    if len(in_shape) < 2 or len(in_shape) > 4:",
   "        return False",
   "    # acuity only support resize width or height",
   "    if in_shape[0] != out_shape[0] or in_shape[1] != out_shape[1]:",
   "        return False",
   "",
   "    unsuppored_trans_mode = [",
   "        #'pytorch_half_pixel',",
   "        #for pytorch_half_pixel, we assue that length_resized will always > 1,",
   "        #in this condition, it equals to 'half_pixel',",
   "        #but if length_resized == 1, there will be some precision issue",
   "        'tf_half_piexl_for_nn',",
   "        'tf_crop_and_resize'",
   "    ]",
   "    trans_mode = self.attr_pick(node['Resize'], 'coordinate_transformation_mode', 'half_pixel')",
   "    if trans_mode in unsuppored_trans_mode:",
   "        return False",
   "",
   "    mode = self.attr_pick(node['Resize'], 'mode', 'nearest')",
   "    nearest_mode = self.attr_pick(node['Resize'], 'nearest_mode', 'round_prefer_floor')",
   "    if mode == 'nearest' and 'ceil' in nearest_mode:",
   "        return False",
   "",
   "    # pytorch coeff_a is -0.75",
   "    # tf coeff_a is -0.5, we only support this coeff_a",
   "    coeff_a = self.attr_pick(node['Resize'], 'cubic_coeff_a', -0.75)",
   "    if mode == 'cubic' and coeff_a != -0.5:",
   "        return False",
   "",
   "    return True",
   ""
  ],
  "src_out_tensor": [
   "Resize:out0"
  ],
  "param_map": {
   "image_resize": {
    "type": [
     "STRING",
     "PYFUNC",
     [
      "def r_resize_get_type(self, node, tensor):",
      "    mode = self.attr_pick(node['Resize'], 'mode', 'nearest').lower()",
      "    _mode_map = {",
      "        \"nearest\": \"nearest\",",
      "        \"linear\": \"bilinear\",",
      "        \"cubic\": \"bicubic\"",
      "    }",
      "",
      "    _maped_mode = \"nearest\"",
      "    if mode in _mode_map.keys():",
      "        _maped_mode = _mode_map[mode]",
      "    return _maped_mode",
      ""
     ]
    ],
    "align_corners": [
     "BOOL",
     "PYFUNC",
     [
      "def r_resize_get_align_corners(self, node, tensor):",
      "    trans_mode = self.attr_pick(node['Resize'], 'coordinate_transformation_mode', 'half_pixel')",
      "    if trans_mode == 'align_corners':",
      "        return True",
      "    return False",
      ""
     ]
    ],
    "half_pixel": [
     "BOOL",
     "PYFUNC",
     [
      "def r_resize_get_half_pixel(self, node, tensor):",
      "    trans_mode = self.attr_pick(node['Resize'], 'coordinate_transformation_mode', 'half_pixel')",
      "    # for pytorch_half_pixel, we assue that length_resized will always > 1,",
      "    # in this condition, it equals to 'half_pixel',",
      "    # but if length_resized == 1, there will be some precision issue",
      "    if trans_mode in ['half_pixel', 'pytorch_half_pixel']:",
      "        return True",
      "    return False",
      ""
     ]
    ],
    "new_size": [
     "INTS",
     "PYFUNC",
     [
      "def r_resize_get_new_size(self, node, tensor):",
      "    out_shape = self.shape_pick(tensor[\"Resize:out0\"])",
      "    new_size = out_shape[2:] # [batch, channel, height, width] or [batch, channel, width]",
      "    return new_size",
      ""
     ]
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant:out0",
    "Resize:in2"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   2,
   10
  ],
  "src_acu_out_tensor_map": [
   [
    "Pad:out0",
    "pad:out0"
   ]
  ],
  "acu_lys_alias": [
   "pad"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "pad:in0"
   ]
  ],
  "ruler_name": "pad_g1",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Pad:in0"
   ]
  ],
  "src_ops_alias": [
   "Pad"
  ],
  "blob_map": {
   "pad": {}
  },
  "pre_condition": null,
  "src_out_tensor": [
   "Pad:out0"
  ],
  "param_map": {
   "pad": {
    "padding_mode": [
     "STRING",
     "CODE",
     "self.attr_pick(node['Pad'], 'mode', 'constant')"
    ],
    "padding_value": [
     "ORIGIN",
     "CODE",
     "self.map_pad_value(node['Pad'])"
    ],
    "padding_const": [
     "ORIGIN",
     "CODE",
     "self.attr_pick(node['Pad'], 'value')"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   11,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Pad:out0",
    "pad:out0"
   ]
  ],
  "acu_lys_alias": [
   "pad"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "pad:in0"
   ]
  ],
  "ruler_name": "r_pad_11",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Pad:in0"
   ]
  ],
  "src_ops_alias": [
   "Pad",
   "Constant"
  ],
  "blob_map": {
   "pad": {}
  },
  "pre_condition": null,
  "src_out_tensor": [
   "Pad:out0"
  ],
  "param_map": {
   "pad": {
    "padding_mode": [
     "STRING",
     "CODE",
     "self.attr_pick(node['Pad'], 'mode', 'constant')"
    ],
    "padding_value": [
     "ORIGIN",
     "PYFUNC",
     [
      "def r_pad_value_map(self, node, tensor):",
      "    pad_np = self.tensor_to_numpy(tensor['Constant:out0'])",
      "    pads = list(pad_np)",
      "    pads = [int(p) for p in pads]",
      "    dims = len(pads) // 2",
      "    pads_array = list()",
      "    if dims == 4:",
      "        for id in range(dims):",
      "            pad = [pads[id], pads[dims + id]]",
      "            pads_array.append(pad)",
      "    elif dims < 4:",
      "        for id in range(dims):",
      "            pad = [pads[id], pads[dims + id]]",
      "            pads_array.append(pad)",
      "    return pads_array",
      ""
     ]
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant:out0",
    "Pad:in1"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Pad:out0",
    "pad:out0"
   ]
  ],
  "acu_lys_alias": [
   "pad"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "pad:in0"
   ]
  ],
  "ruler_name": "r_pad_1",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "Pad:in0"
   ]
  ],
  "src_ops_alias": [
   "Pad",
   "Constant",
   "Constant_1"
  ],
  "blob_map": {
   "pad": {}
  },
  "pre_condition": null,
  "src_out_tensor": [
   "Pad:out0"
  ],
  "param_map": {
   "pad": {
    "padding_mode": [
     "STRING",
     "CODE",
     "self.attr_pick(node['Pad'], 'mode', 'constant')"
    ],
    "padding_value": [
     "ORIGIN",
     "PYFUNC",
     [
      "def r_pad_value_map(self, node, tensor):",
      "    pad_np = self.tensor_to_numpy(tensor['Constant:out0'])",
      "    pads = list(pad_np)",
      "    pads = [int(p) for p in pads]",
      "    dims = len(pads) // 2",
      "    pads_array = list()",
      "    if dims == 4:",
      "        for id in range(dims):",
      "            pad = [pads[id], pads[dims + id]]",
      "            pads_array.append(pad)",
      "    elif dims < 4:",
      "        for id in range(dims):",
      "            pad = [pads[id], pads[dims + id]]",
      "            pads_array.append(pad)",
      "    return pads_array",
      ""
     ]
    ],
    "padding_const": [
     "INT",
     "CODE",
     "self.tensor_to_numpy(tensor['Constant_1:out0'])"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant:out0",
    "Pad:in1"
   ],
   [
    "Constant_1:out0",
    "Pad:in2"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "SpaceToDepth:out0",
    "space2depth:out0"
   ]
  ],
  "acu_lys_alias": [
   "space2depth"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "space2depth:in0"
   ]
  ],
  "ruler_name": "r_space2depth",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "SpaceToDepth:in0"
   ]
  ],
  "src_ops_alias": [
   "SpaceToDepth"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "SpaceToDepth:out0"
  ],
  "param_map": {
   "space2depth": {
    "block_size": [
     "INTS",
     "CODE",
     "[self.attr_pick(node['SpaceToDepth'], 'blocksize'), self.attr_pick(node['SpaceToDepth'], 'blocksize')]"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "DepthToSpace:out0",
    "depth2space:out0"
   ]
  ],
  "acu_lys_alias": [
   "depth2space"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "depth2space:in0"
   ]
  ],
  "ruler_name": "r_depth2space",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "DepthToSpace:in0"
   ]
  ],
  "src_ops_alias": [
   "DepthToSpace"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "DepthToSpace:out0"
  ],
  "param_map": {
   "depth2space": {
    "block_size": [
     "INT",
     "CODE",
     "self.attr_pick(node['DepthToSpace'], 'blocksize')"
    ],
    "mode": [
     "STRING",
     "CODE",
     "self.attr_pick(node['DepthToSpace'], 'mode')"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   5
  ],
  "src_acu_out_tensor_map": [
   [
    "Clip:out0",
    "clipbyvalue:out0"
   ]
  ],
  "acu_lys_alias": [
   "clipbyvalue"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "clipbyvalue:in0"
   ]
  ],
  "ruler_name": "r_clip_1",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "Clip:in0"
   ]
  ],
  "src_ops_alias": [
   "Clip"
  ],
  "blob_map": {
   "clipbyvalue": {}
  },
  "pre_condition": null,
  "src_out_tensor": [
   "Clip:out0"
  ],
  "param_map": {
   "clipbyvalue": {
    "clip_value_min": [
     "FLOAT",
     "CODE",
     "self.attr_pick(node['Clip'], 'min', -1.0)"
    ],
    "clip_value_max": [
     "FLOAT",
     "CODE",
     "self.attr_pick(node['Clip'], 'max', 1.0)"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   6,
   10
  ],
  "src_acu_out_tensor_map": [
   [
    "Clip:out0",
    "clipbyvalue:out0"
   ]
  ],
  "acu_lys_alias": [
   "clipbyvalue"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "clipbyvalue:in0"
   ]
  ],
  "ruler_name": "r_clip_6",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "Clip:in0"
   ]
  ],
  "src_ops_alias": [
   "Clip"
  ],
  "blob_map": {
   "clipbyvalue": {}
  },
  "pre_condition": null,
  "src_out_tensor": [
   "Clip:out0"
  ],
  "param_map": {
   "clipbyvalue": {
    "clip_value_min": [
     "FLOAT",
     "CODE",
     "self.attr_pick(node['Clip'], 'min', -np.inf)"
    ],
    "clip_value_max": [
     "FLOAT",
     "CODE",
     "self.attr_pick(node['Clip'], 'max', np.inf)"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   11,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Clip:out0",
    "clipbyvalue:out0"
   ]
  ],
  "acu_lys_alias": [
   "clipbyvalue"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "clipbyvalue:in0"
   ]
  ],
  "ruler_name": "r_clip_11",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "Clip:in0"
   ]
  ],
  "src_ops_alias": [
   "Clip",
   "Constant",
   "Constant_1"
  ],
  "blob_map": {
   "clipbyvalue": {}
  },
  "pre_condition": null,
  "src_out_tensor": [
   "Clip:out0"
  ],
  "param_map": {
   "clipbyvalue": {
    "clip_value_min": [
     "FLOAT",
     "CODE",
     "self.tensor_to_numpy(tensor['Constant:out0'])"
    ],
    "clip_value_max": [
     "FLOAT",
     "CODE",
     "self.tensor_to_numpy(tensor['Constant_1:out0'])"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant:out0",
    "Clip:in1"
   ],
   [
    "Constant_1:out0",
    "Clip:in2"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Clip:out0",
    "clipbyvalue:out0"
   ]
  ],
  "acu_lys_alias": [
   "clipbyvalue"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "clipbyvalue:in0"
   ]
  ],
  "ruler_name": "r_clip_min",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "Clip:in0"
   ]
  ],
  "src_ops_alias": [
   "Clip",
   "Constant"
  ],
  "blob_map": {
   "clipbyvalue": {}
  },
  "pre_condition": null,
  "src_out_tensor": [
   "Clip:out0"
  ],
  "param_map": {
   "clipbyvalue": {
    "clip_value_min": [
     "FLOAT",
     "CODE",
     "self.tensor_to_numpy(tensor['Constant:out0'])"
    ],
    "clip_value_max": [
     "FLOAT",
     "CODE",
     "np.inf"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant:out0",
    "Clip:in1"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Clip:out0",
    "clipbyvalue:out0"
   ]
  ],
  "acu_lys_alias": [
   "clipbyvalue"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "clipbyvalue:in0"
   ]
  ],
  "ruler_name": "r_clip_max",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "Clip:in0"
   ]
  ],
  "src_ops_alias": [
   "Clip",
   "Constant"
  ],
  "blob_map": {
   "clipbyvalue": {}
  },
  "pre_condition": null,
  "src_out_tensor": [
   "Clip:out0"
  ],
  "param_map": {
   "clipbyvalue": {
    "clip_value_min": [
     "FLOAT",
     "CODE",
     "-np.inf"
    ],
    "clip_value_max": [
     "FLOAT",
     "CODE",
     "self.tensor_to_numpy(tensor['Constant:out0'])"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant:out0",
    "Clip:in2"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Clip:out0",
    "clipbyvalue:out0"
   ]
  ],
  "acu_lys_alias": [
   "clipbyvalue"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "clipbyvalue:in0"
   ]
  ],
  "ruler_name": "r_clip_3inputs",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "Clip:in0"
   ],
   [
    "I_1:out0",
    "Clip:in1"
   ],
   [
    "I_2:out0",
    "Clip:in2"
   ]
  ],
  "src_ops_alias": [
   "Clip"
  ],
  "blob_map": {
   "clipbyvalue": {}
  },
  "pre_condition": null,
  "src_out_tensor": [
   "Clip:out0"
  ],
  "param_map": {
   "clipbyvalue": {
    "clip_value_min": [
     "FLOAT",
     "CODE",
     "self.tensor_to_numpy(tensor['I_1:out0'])"
    ],
    "clip_value_max": [
     "FLOAT",
     "CODE",
     "self.tensor_to_numpy(tensor['I_2:out0'])"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "ReduceMean:out0",
    "reducemean:out0"
   ]
  ],
  "acu_lys_alias": [
   "reducemean"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "reducemean:in0"
   ]
  ],
  "ruler_name": "r_reducemean",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "ReduceMean:in0"
   ]
  ],
  "src_ops_alias": [
   "ReduceMean"
  ],
  "blob_map": {
   "reducemean": {}
  },
  "pre_condition": null,
  "src_out_tensor": [
   "ReduceMean:out0"
  ],
  "param_map": {
   "reducemean": {
    "keep_dims": [
     "BOOL",
     "CODE",
     "self.attr_pick(node['ReduceMean'], 'keepdims', 1)"
    ],
    "axis_list": [
     "INTS",
     "CODE",
     "self.reducex_axis_list(node['ReduceMean'], self.shape_pick(tensor['I_0:out0']))"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "ReduceMax:out0",
    "reducemax:out0"
   ]
  ],
  "acu_lys_alias": [
   "reducemax"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "reducemax:in0"
   ]
  ],
  "ruler_name": "r_reducemax",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "ReduceMax:in0"
   ]
  ],
  "src_ops_alias": [
   "ReduceMax"
  ],
  "blob_map": {
   "reducemax": {}
  },
  "pre_condition": null,
  "src_out_tensor": [
   "ReduceMax:out0"
  ],
  "param_map": {
   "reducemax": {
    "keep_dims": [
     "BOOL",
     "CODE",
     "self.attr_pick(node['ReduceMax'], 'keepdims', 1)"
    ],
    "axis_list": [
     "INTS",
     "CODE",
     "self.reducex_axis_list(node['ReduceMax'], self.shape_pick(tensor['I_0:out0']))"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "ReduceMin:out0",
    "reducemin:out0"
   ]
  ],
  "acu_lys_alias": [
   "reducemin"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "reducemin:in0"
   ]
  ],
  "ruler_name": "r_reducemin",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "ReduceMin:in0"
   ]
  ],
  "src_ops_alias": [
   "ReduceMin"
  ],
  "blob_map": {
   "reducemin": {}
  },
  "pre_condition": null,
  "src_out_tensor": [
   "ReduceMin:out0"
  ],
  "param_map": {
   "reducemin": {
    "keep_dims": [
     "BOOL",
     "CODE",
     "self.attr_pick(node['ReduceMin'], 'keepdims', 1)"
    ],
    "axis_list": [
     "INTS",
     "CODE",
     "self.reducex_axis_list(node['ReduceMin'], self.shape_pick(tensor['I_0:out0']))"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "ReduceSum:out0",
    "reducesum:out0"
   ]
  ],
  "acu_lys_alias": [
   "reducesum"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "reducesum:in0"
   ]
  ],
  "ruler_name": "r_reducesum",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "ReduceSum:in0"
   ]
  ],
  "src_ops_alias": [
   "ReduceSum"
  ],
  "blob_map": {
   "reducesum": {}
  },
  "pre_condition": null,
  "src_out_tensor": [
   "ReduceSum:out0"
  ],
  "param_map": {
   "reducesum": {
    "keep_dims": [
     "BOOL",
     "CODE",
     "self.attr_pick(node['ReduceSum'], 'keepdims', 1)"
    ],
    "axis_list": [
     "INTS",
     "CODE",
     "self.reducex_axis_list(node['ReduceSum'], self.shape_pick(tensor['I_0:out0']))"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   13,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "ReduceSum:out0",
    "reducesum:out0"
   ]
  ],
  "acu_lys_alias": [
   "reducesum"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "reducesum:in0"
   ]
  ],
  "ruler_name": "r_reducesum_with_constant_axes",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "ReduceSum:in0"
   ]
  ],
  "src_ops_alias": [
   "ReduceSum",
   "Constant"
  ],
  "blob_map": {
   "reducesum": {}
  },
  "pre_condition": "not (len(self.tensor_to_numpy(tensor['Constant:out0']).tolist()) == 0 and self.attr_pick(node['ReduceSum'], 'noop_with_empty_axes', 0) == 1)",
  "src_out_tensor": [
   "ReduceSum:out0"
  ],
  "param_map": {
   "reducesum": {
    "keep_dims": [
     "BOOL",
     "CODE",
     "self.attr_pick(node['ReduceSum'], 'keepdims', 1)"
    ],
    "axis_list": [
     "INTS",
     "CODE",
     "self.reducesum_constant_axis_list(node['ReduceSum'], tensor['Constant:out0'], self.shape_pick(tensor['I_0:out0']))"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant:out0",
    "ReduceSum:in1"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   13,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "ReduceSum:out0",
    "noop:out0"
   ]
  ],
  "acu_lys_alias": [
   "noop"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "noop:in0"
   ]
  ],
  "ruler_name": "r_reducesum_to_noop_with_constant_axes",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "ReduceSum:in0"
   ]
  ],
  "src_ops_alias": [
   "ReduceSum",
   "Constant"
  ],
  "blob_map": {},
  "pre_condition": "len(self.tensor_to_numpy(tensor['Constant:out0']).tolist()) == 0 and self.attr_pick(node['ReduceSum'], 'noop_with_empty_axes', 0) == 1",
  "src_out_tensor": [
   "ReduceSum:out0"
  ],
  "param_map": {},
  "src_inter_flow": [
   [
    "Constant:out0",
    "ReduceSum:in1"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "ReduceProd:out0",
    "reduceprod:out0"
   ]
  ],
  "acu_lys_alias": [
   "reduceprod"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "reduceprod:in0"
   ]
  ],
  "ruler_name": "r_reduceprod",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "ReduceProd:in0"
   ]
  ],
  "src_ops_alias": [
   "ReduceProd"
  ],
  "blob_map": {
   "reduceprod": {}
  },
  "pre_condition": null,
  "src_out_tensor": [
   "ReduceProd:out0"
  ],
  "param_map": {
   "reduceprod": {
    "keep_dims": [
     "BOOL",
     "CODE",
     "self.attr_pick(node['ReduceProd'], 'keepdims', 1)"
    ],
    "axis_list": [
     "INTS",
     "CODE",
     "self.reducex_axis_list(node['ReduceProd'], self.shape_pick(tensor['I_0:out0']))"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "ReduceL1:out0",
    "reducesum:out0"
   ]
  ],
  "acu_lys_alias": [
   "abs",
   "reducesum"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "abs:in0"
   ]
  ],
  "ruler_name": "r_reducel1",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "ReduceL1:in0"
   ]
  ],
  "src_ops_alias": [
   "ReduceL1"
  ],
  "blob_map": {
   "abs": {},
   "reducesum": {}
  },
  "pre_condition": null,
  "src_out_tensor": [
   "ReduceL1:out0"
  ],
  "param_map": {
   "abs": {},
   "reducesum": {
    "keep_dims": [
     "BOOL",
     "CODE",
     "self.attr_pick(node['ReduceL1'], 'keepdims', 1)"
    ],
    "axis_list": [
     "INTS",
     "CODE",
     "self.reducex_axis_list(node['ReduceL1'], self.shape_pick(tensor['I_0:out0']))"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": [
   [
    "abs:out0",
    "reducesum:in0"
   ]
  ]
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "ReduceL2:out0",
    "sqrt:out0"
   ]
  ],
  "acu_lys_alias": [
   "reducesum",
   "multiply",
   "sqrt"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "multiply:in0"
   ],
   [
    "I_0:out0",
    "multiply:in1"
   ]
  ],
  "ruler_name": "r_reducel2",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "ReduceL2:in0"
   ]
  ],
  "src_ops_alias": [
   "ReduceL2"
  ],
  "blob_map": {
   "reducesum": {},
   "sqrt": {},
   "multiply": {}
  },
  "pre_condition": null,
  "src_out_tensor": [
   "ReduceL2:out0"
  ],
  "param_map": {
   "reducesum": {
    "keep_dims": [
     "BOOL",
     "CODE",
     "self.attr_pick(node['ReduceL2'], 'keepdims', 1)"
    ],
    "axis_list": [
     "INTS",
     "CODE",
     "self.reducex_axis_list(node['ReduceL2'], self.shape_pick(tensor['I_0:out0']))"
    ]
   },
   "sqrt": {},
   "multiply": {}
  },
  "src_inter_flow": [],
  "acu_inter_flow": [
   [
    "multiply:out0",
    "reducesum:in0"
   ],
   [
    "reducesum:out0",
    "sqrt:in0"
   ]
  ]
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "ReduceLogSum:out0",
    "log:out0"
   ]
  ],
  "acu_lys_alias": [
   "reducesum",
   "log"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "reducesum:in0"
   ]
  ],
  "ruler_name": "r_reducelogsum",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "ReduceLogSum:in0"
   ]
  ],
  "src_ops_alias": [
   "ReduceLogSum"
  ],
  "blob_map": {
   "reducesum": {},
   "log": {}
  },
  "pre_condition": null,
  "src_out_tensor": [
   "ReduceLogSum:out0"
  ],
  "param_map": {
   "reducesum": {
    "keep_dims": [
     "BOOL",
     "CODE",
     "self.attr_pick(node['ReduceLogSum'], 'keepdims', 1)"
    ],
    "axis_list": [
     "INTS",
     "CODE",
     "self.reducex_axis_list(node['ReduceLogSum'], self.shape_pick(tensor['I_0:out0']))"
    ]
   },
   "log": {}
  },
  "src_inter_flow": [],
  "acu_inter_flow": [
   [
    "reducesum:out0",
    "log:in0"
   ]
  ]
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "ReduceLogSumExp:out0",
    "log:out0"
   ]
  ],
  "acu_lys_alias": [
   "exp",
   "reducesum",
   "log"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "exp:in0"
   ]
  ],
  "ruler_name": "r_reducelogsumexp",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "ReduceLogSumExp:in0"
   ]
  ],
  "src_ops_alias": [
   "ReduceLogSumExp"
  ],
  "blob_map": {
   "exp": {},
   "reducesum": {},
   "log": {}
  },
  "pre_condition": null,
  "src_out_tensor": [
   "ReduceLogSumExp:out0"
  ],
  "param_map": {
   "exp": {},
   "reducesum": {
    "keep_dims": [
     "BOOL",
     "CODE",
     "self.attr_pick(node['ReduceLogSumExp'], 'keepdims', 1)"
    ],
    "axis_list": [
     "INTS",
     "CODE",
     "self.reducex_axis_list(node['ReduceLogSumExp'], self.shape_pick(tensor['I_0:out0']))"
    ]
   },
   "log": {}
  },
  "src_inter_flow": [],
  "acu_inter_flow": [
   [
    "exp:out0",
    "reducesum:in0"
   ],
   [
    "reducesum:out0",
    "log:in0"
   ]
  ]
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "ReduceSumSquare:out0",
    "reducesum:out0"
   ]
  ],
  "acu_lys_alias": [
   "multiply",
   "reducesum"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "multiply:in0"
   ],
   [
    "I_0:out0",
    "multiply:in1"
   ]
  ],
  "ruler_name": "r_ReduceSumSquare",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "ReduceSumSquare:in0"
   ]
  ],
  "src_ops_alias": [
   "ReduceSumSquare"
  ],
  "blob_map": {
   "reducesum": {},
   "multiply": {}
  },
  "pre_condition": null,
  "src_out_tensor": [
   "ReduceSumSquare:out0"
  ],
  "param_map": {
   "reducesum": {
    "keep_dims": [
     "BOOL",
     "CODE",
     "self.attr_pick(node['ReduceSumSquare'], 'keepdims', 1)"
    ],
    "axis_list": [
     "INTS",
     "CODE",
     "self.reducex_axis_list(node['ReduceSumSquare'], self.shape_pick(tensor['I_0:out0']))"
    ]
   },
   "multiply": {}
  },
  "src_inter_flow": [],
  "acu_inter_flow": [
   [
    "multiply:out0",
    "reducesum:in0"
   ]
  ]
 },
 {
  "src_acu_out_tensor_map": [
   [
    "Gather:out0",
    "gather:out0"
   ]
  ],
  "acu_lys_alias": [
   "gather"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "gather:in0"
   ],
   [
    "I_1:out0",
    "gather:in1"
   ]
  ],
  "ruler_name": "r_gather",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Gather:in0"
   ],
   [
    "I_1:out0",
    "Gather:in1"
   ]
  ],
  "src_ops_alias": [
   "Gather"
  ],
  "blob_map": {
   "gather": {}
  },
  "pre_condition": null,
  "src_out_tensor": [
   "Gather:out0"
  ],
  "param_map": {
   "gather": {
    "axis": [
     "INT",
     "CODE",
     "self.attr_pick(node['Gather'], 'axis', 0)"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_acu_out_tensor_map": [
   [
    "GatherND:out0",
    "gathernd:out0"
   ]
  ],
  "acu_lys_alias": [
   "gathernd"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "gathernd:in0"
   ],
   [
    "I_1:out0",
    "gathernd:in1"
   ]
  ],
  "ruler_name": "r_gather_nd",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "GatherND:in0"
   ],
   [
    "I_1:out0",
    "GatherND:in1"
   ]
  ],
  "src_ops_alias": [
   "GatherND"
  ],
  "blob_map": {
   "gathernd": {}
  },
  "pre_condition": null,
  "src_out_tensor": [
   "GatherND:out0"
  ],
  "param_map": {
   "gathernd": {
    "batch_dims": [
     "INT",
     "CODE",
     "self.attr_pick(node['GatherND'], 'batch_dims', 0)"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Softplus:out0",
    "softrelu:out0"
   ]
  ],
  "acu_lys_alias": [
   "softrelu"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "softrelu:in0"
   ]
  ],
  "ruler_name": "r_softplus",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "Softplus:in0"
   ]
  ],
  "src_ops_alias": [
   "Softplus"
  ],
  "blob_map": {
   "softrelu": {}
  },
  "pre_condition": null,
  "src_out_tensor": [
   "Softplus:out0"
  ],
  "param_map": {
   "softrelu": {}
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Tile:out0",
    "tile:out0"
   ]
  ],
  "acu_lys_alias": [
   "tile"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "tile:in0"
   ]
  ],
  "ruler_name": "r_tile",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Tile:in0"
   ]
  ],
  "src_ops_alias": [
   "Tile",
   "Constant_0"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "Tile:out0"
  ],
  "param_map": {
   "tile": {
    "multiples": [
     "INTS",
     "CODE",
     "self.tensor_to_numpy(tensor['Constant_0:out0'])"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant_0:out0",
    "Tile:in1"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "ArgMin:out0",
    "argmin:out0"
   ]
  ],
  "acu_lys_alias": [
   "argmin"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "argmin:in0"
   ]
  ],
  "ruler_name": "r_argmin",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "ArgMin:in0"
   ]
  ],
  "src_ops_alias": [
   "ArgMin"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "ArgMin:out0"
  ],
  "param_map": {
   "argmin": {
    "axis": [
     "INT",
     "CODE",
     "self.attr_pick(node['ArgMin'], 'axis', 0)"
    ],
    "keepdims": [
     "BOOL",
     "CODE",
     "self.attr_pick(node['ArgMin'], 'keepdims', 1)"
    ],
    "output_type": [
     "STRING",
     "CODE",
     "self.dtype_pick(tensor['ArgMin:out0'])"
    ],
    "select_last_index": [
     "BOOL",
     "CODE",
     "self.attr_pick(node['ArgMin'], 'select_last_index', 0)"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "ArgMax:out0",
    "argmax:out0"
   ]
  ],
  "acu_lys_alias": [
   "argmax"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "argmax:in0"
   ]
  ],
  "ruler_name": "r_argmax",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "ArgMax:in0"
   ]
  ],
  "src_ops_alias": [
   "ArgMax"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "ArgMax:out0"
  ],
  "param_map": {
   "argmax": {
    "output_type": [
     "STRING",
     "CODE",
     "self.dtype_pick(tensor['ArgMax:out0'])"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": null,
  "src_acu_out_tensor_map": [
   [
    "Neg:out0",
    "neg:out0"
   ]
  ],
  "acu_lys_alias": [
   "neg"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "neg:in0"
   ]
  ],
  "ruler_name": "r_neg",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Neg:in0"
   ]
  ],
  "src_ops_alias": [
   "Neg"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "Neg:out0"
  ],
  "param_map": {},
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Sin:out0",
    "sin:out0"
   ]
  ],
  "acu_lys_alias": [
   "sin"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "sin:in0"
   ]
  ],
  "ruler_name": "r_sin",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "Sin:in0"
   ]
  ],
  "src_ops_alias": [
   "Sin"
  ],
  "blob_map": {
   "sin": {}
  },
  "pre_condition": null,
  "src_out_tensor": [
   "Sin:out0"
  ],
  "param_map": {
   "sin": {}
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "ReverseSequence:out0",
    "reverse_sequence:out0"
   ]
  ],
  "acu_lys_alias": [
   "reverse_sequence"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "reverse_sequence:in0"
   ],
   [
    "I_0:out0",
    "reverse_sequence:in1"
   ]
  ],
  "ruler_name": "r_reverse_sequence",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "ReverseSequence:in0"
   ],
   [
    "I_0:out0",
    "ReverseSequence:in1"
   ]
  ],
  "src_ops_alias": [
   "ReverseSequence"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "ReverseSequence:out0"
  ],
  "param_map": {
   "reverse_sequence": {
    "seq_axis": [
     "INT",
     "CODE",
     "self.attr_pick(node['ReverseSequence'], 'time_axis', 0)"
    ],
    "batch_axis": [
     "INT",
     "CODE",
     "self.attr_pick(node['ReverseSequence'], 'batch_axis', 1)"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Where:out0",
    "where:out0"
   ]
  ],
  "acu_lys_alias": [
   "where"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "where:in0"
   ],
   [
    "I_1:out0",
    "where:in1"
   ],
   [
    "I_2:out0",
    "where:in2"
   ]
  ],
  "ruler_name": "r_where",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "Where:in0"
   ],
   [
    "I_1:out0",
    "Where:in1"
   ],
   [
    "I_2:out0",
    "Where:in2"
   ]
  ],
  "src_ops_alias": [
   "Where"
  ],
  "blob_map": {
   "where": {}
  },
  "pre_condition": null,
  "src_out_tensor": [
   "Where:out0"
  ],
  "param_map": {
   "where": {}
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "MatMul:out0",
    "matmul:out0"
   ]
  ],
  "acu_lys_alias": [
   "matmul"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "matmul:in0"
   ],
   [
    "I_1:out0",
    "matmul:in1"
   ]
  ],
  "ruler_name": "r_matmul",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "MatMul:in0"
   ],
   [
    "I_1:out0",
    "MatMul:in1"
   ]
  ],
  "src_ops_alias": [
   "MatMul"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "MatMul:out0"
  ],
  "param_map": {
   "matmul": {
    "transpose_b": [
     "BOOL",
     "CODE",
     "self.attr_pick(node['MatMul'], 'transpose_b', False)"
    ],
    "transpose_a": [
     "BOOL",
     "CODE",
     "self.attr_pick(node['MatMul'], 'transpose_a', False)"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Xor:out0",
    "not_equal:out0"
   ]
  ],
  "acu_lys_alias": [
   "not_equal"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "not_equal:in0"
   ],
   [
    "I_1:out0",
    "not_equal:in1"
   ]
  ],
  "ruler_name": "r_logical_xor",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "Xor:in0"
   ],
   [
    "I_1:out0",
    "Xor:in1"
   ]
  ],
  "src_ops_alias": [
   "Xor"
  ],
  "blob_map": {
   "not_equal": {}
  },
  "pre_condition": null,
  "src_out_tensor": [
   "Xor:out0"
  ],
  "param_map": {
   "not_equal": {}
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Expand:out0",
    "expand_broadcast:out0"
   ]
  ],
  "acu_lys_alias": [
   "expand_broadcast"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "expand_broadcast:in0"
   ]
  ],
  "ruler_name": "r_expand",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "Expand:in0"
   ]
  ],
  "src_ops_alias": [
   "Expand",
   "Constant"
  ],
  "blob_map": {
   "expand_broadcast": {}
  },
  "pre_condition": null,
  "src_out_tensor": [
   "Expand:out0"
  ],
  "param_map": {
   "expand_broadcast": {
    "shape": [
     "INTS",
     "CODE",
     "self.tensor_to_numpy(tensor['Constant:out0'])"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant:out0",
    "Expand:in1"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Expand:out0",
    "expand_broadcast:out0"
   ]
  ],
  "acu_lys_alias": [
   "expand_broadcast"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "expand_broadcast:in0"
   ]
  ],
  "ruler_name": "r_expand_dynamic",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "Expand:in0"
   ],
   [
    "I_1:out0",
    "Expand:in1"
   ]
  ],
  "src_ops_alias": [
   "Expand"
  ],
  "blob_map": {
   "expand_broadcast": {}
  },
  "pre_condition": null,
  "src_out_tensor": [
   "Expand:out0"
  ],
  "param_map": {
   "expand_broadcast": {
    "shape": [
     "INTS",
     "CODE",
     "self.tensor_to_numpy(tensor['I_1:out0'])"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "QuantizeLinear:out0",
    "quantize:out0"
   ]
  ],
  "acu_lys_alias": [
   "quantize"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "quantize:in0"
   ]
  ],
  "ruler_name": "r_quantizelinear",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "QuantizeLinear:in0"
   ]
  ],
  "src_ops_alias": [
   "QuantizeLinear",
   "Constant",
   "Constant_1"
  ],
  "blob_map": {
   "quantize": {}
  },
  "pre_condition": null,
  "src_out_tensor": [
   "QuantizeLinear:out0"
  ],
  "param_map": {
   "quantize": {}
  },
  "src_inter_flow": [
   [
    "Constant:out0",
    "QuantizeLinear:in1"
   ],
   [
    "Constant_1:out0",
    "QuantizeLinear:in2"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "DequantizeLinear:out0",
    "dequantize:out0"
   ]
  ],
  "acu_lys_alias": [
   "dequantize"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "dequantize:in0"
   ]
  ],
  "ruler_name": "r_dequantizelinear",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "DequantizeLinear:in0"
   ]
  ],
  "src_ops_alias": [
   "DequantizeLinear",
   "Constant",
   "Constant_1"
  ],
  "blob_map": {
   "dequantize": {}
  },
  "pre_condition": null,
  "src_out_tensor": [
   "DequantizeLinear:out0"
  ],
  "param_map": {
   "dequantize": {}
  },
  "src_inter_flow": [
   [
    "Constant:out0",
    "DequantizeLinear:in1"
   ],
   [
    "Constant_1:out0",
    "DequantizeLinear:in2"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "QLinearMatMul:out0",
    "matmul:out0"
   ]
  ],
  "acu_lys_alias": [
   "matmul"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "matmul:in0"
   ],
   [
    "I_1:out0",
    "matmul:in1"
   ]
  ],
  "ruler_name": "qlinearmatmul",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "QLinearMatMul:in0"
   ],
   [
    "I_1:out0",
    "QLinearMatMul:in3"
   ]
  ],
  "src_ops_alias": [
   "QLinearMatMul",
   "Constant",
   "Constant_1",
   "Constant_2",
   "Constant_3",
   "Constant_4",
   "Constant_5"
  ],
  "blob_map": {
   "matmul": {}
  },
  "pre_condition": null,
  "src_out_tensor": [
   "QLinearMatMul:out0"
  ],
  "param_map": {
   "matmul": {}
  },
  "src_inter_flow": [
   [
    "Constant:out0",
    "QLinearMatMul:in1"
   ],
   [
    "Constant_1:out0",
    "QLinearMatMul:in2"
   ],
   [
    "Constant_2:out0",
    "QLinearMatMul:in4"
   ],
   [
    "Constant_3:out0",
    "QLinearMatMul:in5"
   ],
   [
    "Constant_4:out0",
    "QLinearMatMul:in6"
   ],
   [
    "Constant_5:out0",
    "QLinearMatMul:in7"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "QLinearConv:out0",
    "convolution:out0"
   ]
  ],
  "acu_lys_alias": [
   "convolution"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "convolution:in0"
   ]
  ],
  "ruler_name": "qlinearconv_no_bias",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "QLinearConv:in0"
   ]
  ],
  "src_ops_alias": [
   "QLinearConv",
   "Constant",
   "Constant_1",
   "Constant_2",
   "Constant_3",
   "Constant_4",
   "Constant_5",
   "Constant_6"
  ],
  "blob_map": {
   "convolution": {
    "weight": [
     "CODE",
     "self.qtensor_to_numpy(tensor['Constant_2:out0'],self.tensor_to_numpy(tensor['Constant_3:out0']),self.tensor_to_numpy(tensor['Constant_4:out0']))"
    ]
   }
  },
  "pre_condition": null,
  "src_out_tensor": [
   "QLinearConv:out0"
  ],
  "param_map": {
   "convolution": {
    "pad_method": [
     "STRING",
     "CODE",
     "'auto' if self.attr_pick(node['QLinearConv'], 'auto_pad', 'NOTSET') != 'NOTSET' else 'padding_const'"
    ],
    "pad": [
     "INTS",
     "CODE",
     "[p for p in self.array_layout(self.attr_pick(node['QLinearConv'], 'pads', [ 0, 0, 0, 0]), [0, 2, 1, 3])]"
    ],
    "group_number": [
     "INT",
     "CODE",
     "self.attr_pick(node['QLinearConv'], 'group', 1)"
    ],
    "ksize_w": [
     "INT",
     "CODE",
     "self.shape_pick(tensor['Constant_2:out0'])[3]"
    ],
    "bias": [
     "BOOL",
     "VALUE",
     false
    ],
    "stride_h": [
     "INT",
     "CODE",
     "self.attr_pick(node['QLinearConv'], 'strides', default=[1,1])[0]"
    ],
    "stride_w": [
     "INT",
     "CODE",
     "self.attr_pick(node['QLinearConv'], 'strides', default =[1,1])[1]"
    ],
    "weights": [
     "INT",
     "CODE",
     "self.shape_pick(tensor['Constant_2:out0'])[0]"
    ],
    "dilation": [
     "INT",
     "CODE",
     "self.attr_pick(node['QLinearConv'], 'dilations') if isinstance(self.attr_pick(node['QLinearConv'], 'dilations'), int) else self.attr_pick(node['QLinearConv'], 'dilations')[0]"
    ],
    "padding": [
     "STRING",
     "CODE",
     "'SAME' if self.attr_pick(node['QLinearConv'], 'auto_pad', 'NOTSET') in ['SAME_UPPER', 'SAME_LOWER'] else 'VALID' "
    ],
    "ksize_h": [
     "INT",
     "CODE",
     "self.shape_pick(tensor['Constant_2:out0'])[2]"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant:out0",
    "QLinearConv:in1"
   ],
   [
    "Constant_1:out0",
    "QLinearConv:in2"
   ],
   [
    "Constant_2:out0",
    "QLinearConv:in3"
   ],
   [
    "Constant_3:out0",
    "QLinearConv:in4"
   ],
   [
    "Constant_4:out0",
    "QLinearConv:in5"
   ],
   [
    "Constant_5:out0",
    "QLinearConv:in6"
   ],
   [
    "Constant_6:out0",
    "QLinearConv:in7"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "QLinearConv:out0",
    "convolution:out0"
   ]
  ],
  "acu_lys_alias": [
   "convolution"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "convolution:in0"
   ]
  ],
  "ruler_name": "qlinearconv_with_bias",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "QLinearConv:in0"
   ]
  ],
  "src_ops_alias": [
   "QLinearConv",
   "Constant",
   "Constant_1",
   "Constant_2",
   "Constant_3",
   "Constant_4",
   "Constant_5",
   "Constant_6",
   "Constant_7"
  ],
  "blob_map": {
   "convolution": {
    "weight": [
     "CODE",
     "self.qtensor_to_numpy(tensor['Constant_2:out0'],self.tensor_to_numpy(tensor['Constant_3:out0']),self.tensor_to_numpy(tensor['Constant_4:out0']))"
    ],
    "bias": [
     "CODE",
     "self.qtensor_to_numpy(tensor['Constant_7:out0'],self.tensor_to_numpy(tensor['Constant:out0'])*self.tensor_to_numpy(tensor['Constant_3:out0']),np.array([0]*self.shape_pick(tensor['Constant_2:out0'])[0],dtype=np.int32))"
    ]
   }
  },
  "pre_condition": null,
  "src_out_tensor": [
   "QLinearConv:out0"
  ],
  "param_map": {
   "convolution": {
    "pad_method": [
     "STRING",
     "CODE",
     "'auto' if self.attr_pick(node['QLinearConv'], 'auto_pad', 'NOTSET') != 'NOTSET' else 'padding_const'"
    ],
    "pad": [
     "INTS",
     "CODE",
     "[p for p in self.array_layout(self.attr_pick(node['QLinearConv'], 'pads', [ 0, 0, 0, 0]), [0, 2, 1, 3])]"
    ],
    "group_number": [
     "INT",
     "CODE",
     "self.attr_pick(node['QLinearConv'], 'group', 1)"
    ],
    "ksize_w": [
     "INT",
     "CODE",
     "self.shape_pick(tensor['Constant_2:out0'])[3]"
    ],
    "bias": [
     "BOOL",
     "VALUE",
     true
    ],
    "stride_h": [
     "INT",
     "CODE",
     "self.attr_pick(node['QLinearConv'], 'strides', default=[1,1])[0]"
    ],
    "stride_w": [
     "INT",
     "CODE",
     "self.attr_pick(node['QLinearConv'], 'strides', default =[1,1])[1]"
    ],
    "weights": [
     "INT",
     "CODE",
     "self.shape_pick(tensor['Constant_2:out0'])[0]"
    ],
    "dilation": [
     "INT",
     "CODE",
     "self.attr_pick(node['QLinearConv'], 'dilations') if isinstance(self.attr_pick(node['QLinearConv'], 'dilations'), int) else self.attr_pick(node['QLinearConv'], 'dilations')[0]"
    ],
    "padding": [
     "STRING",
     "CODE",
     "'SAME' if self.attr_pick(node['QLinearConv'], 'auto_pad', 'NOTSET') in ['SAME_UPPER', 'SAME_LOWER'] else 'VALID' "
    ],
    "ksize_h": [
     "INT",
     "CODE",
     "self.shape_pick(tensor['Constant_2:out0'])[2]"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant:out0",
    "QLinearConv:in1"
   ],
   [
    "Constant_1:out0",
    "QLinearConv:in2"
   ],
   [
    "Constant_2:out0",
    "QLinearConv:in3"
   ],
   [
    "Constant_3:out0",
    "QLinearConv:in4"
   ],
   [
    "Constant_4:out0",
    "QLinearConv:in5"
   ],
   [
    "Constant_5:out0",
    "QLinearConv:in6"
   ],
   [
    "Constant_6:out0",
    "QLinearConv:in7"
   ],
   [
    "Constant_7:out0",
    "QLinearConv:in8"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "QLinearConv:out0",
    "conv1d:out0"
   ]
  ],
  "acu_lys_alias": [
   "conv1d"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "conv1d:in0"
   ]
  ],
  "ruler_name": "qlinearconv_1d_with_bias_share_zp",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "QLinearConv:in0"
   ]
  ],
  "src_ops_alias": [
   "QLinearConv",
   "Constant",
   "Constant_1",
   "Constant_2",
   "Constant_3",
   "Constant_4",
   "Constant_5"
  ],
  "blob_map": {
   "conv1d": {
    "weight": [
     "CODE",
     "self.qtensor_to_numpy(tensor['Constant_2:out0'],self.tensor_to_numpy(tensor['Constant_3:out0']),self.tensor_to_numpy(tensor['Constant_1:out0']))"
    ],
    "bias": [
     "CODE",
     "self.qtensor_to_numpy(tensor['Constant_5:out0'],self.tensor_to_numpy(tensor['Constant:out0'])*self.tensor_to_numpy(tensor['Constant_3:out0']),np.array([0]*self.shape_pick(tensor['Constant_2:out0'])[0],dtype=np.int32))"
    ]
   }
  },
  "pre_condition": null,
  "src_out_tensor": [
   "QLinearConv:out0"
  ],
  "param_map": {
   "conv1d": {
    "pad_method": [
     "STRING",
     "CODE",
     "'auto' if self.attr_pick(node['QLinearConv'], 'auto_pad', 'NOTSET') != 'NOTSET' else 'padding_const'"
    ],
    "stride": [
     "INT",
     "CODE",
     "self.attr_pick(node['QLinearConv'], 'strides', default=[1])[0]"
    ],
    "pad": [
     "INTS",
     "CODE",
     "[p for p in self.array_layout(self.attr_pick(node['QLinearConv'], 'pads', [ 0, 0,]), [0, 1])]"
    ],
    "ksize": [
     "INT",
     "CODE",
     "self.shape_pick(tensor['Constant_2:out0'])[2]"
    ],
    "group_number": [
     "INT",
     "CODE",
     "self.attr_pick(node['QLinearConv'], 'group', 1)"
    ],
    "bias": [
     "BOOL",
     "VALUE",
     true
    ],
    "weights": [
     "INT",
     "CODE",
     "self.shape_pick(tensor['Constant_2:out0'])[0]"
    ],
    "padding": [
     "STRING",
     "CODE",
     "'SAME' if self.attr_pick(node['QLinearConv'], 'auto_pad', 'NOTSET') in ['SAME_UPPER', 'SAME_LOWER'] else 'VALID' "
    ],
    "dilation": [
     "INT",
     "CODE",
     "self.attr_pick(node['QLinearConv'], 'dilations') if isinstance(self.attr_pick(node['QLinearConv'], 'dilations'), int) else self.attr_pick(node['QLinearConv'], 'dilations')[0]"
    ]
   }
  },
  "src_inter_flow": [
   [
    "Constant:out0",
    "QLinearConv:in1"
   ],
   [
    "Constant_1:out0",
    "QLinearConv:in2"
   ],
   [
    "Constant_2:out0",
    "QLinearConv:in3"
   ],
   [
    "Constant_3:out0",
    "QLinearConv:in4"
   ],
   [
    "Constant_1:out0",
    "QLinearConv:in5"
   ],
   [
    "Constant_4:out0",
    "QLinearConv:in6"
   ],
   [
    "Constant_1:out0",
    "QLinearConv:in7"
   ],
   [
    "Constant_5:out0",
    "QLinearConv:in8"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Div:out0",
    "hard_swish:out0"
   ]
  ],
  "acu_lys_alias": [
   "hard_swish"
  ],
  "src_acu_in_tensor_map": [
   [
    "I_0:out0",
    "hard_swish:in0"
   ]
  ],
  "ruler_name": "r_hard_swish",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I_0:out0",
    "Add:in0"
   ],
   [
    "I_0:out0",
    "Mul:in0"
   ]
  ],
  "src_ops_alias": [
   "Div",
   "Mul",
   "Constant",
   "Clip",
   "Add",
   "Constant_1",
   "Constant_2",
   "Constant_3"
  ],
  "blob_map": {
   "hard_swish": {}
  },
  "pre_condition": null,
  "src_out_tensor": [
   "Div:out0"
  ],
  "param_map": {
   "hard_swish": {}
  },
  "src_inter_flow": [
   [
    "Mul:out0",
    "Div:in0"
   ],
   [
    "Constant:out0",
    "Div:in1"
   ],
   [
    "Clip:out0",
    "Mul:in1"
   ],
   [
    "Add:out0",
    "Clip:in0"
   ],
   [
    "Constant_1:out0",
    "Clip:in1"
   ],
   [
    "Constant_2:out0",
    "Clip:in2"
   ],
   [
    "Constant_3:out0",
    "Add:in1"
   ]
  ],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "NonZero:out0",
    "nonzero:out0"
   ]
  ],
  "acu_lys_alias": [
   "nonzero"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "nonzero:in0"
   ]
  ],
  "ruler_name": "r_nonzero",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "NonZero:in0"
   ]
  ],
  "src_ops_alias": [
   "NonZero"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "NonZero:out0"
  ],
  "param_map": {
   "nonzero": {
    "output_type": [
     "STRING",
     "CODE",
     "self.dtype_pick(tensor['NonZero:out0'])"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Shape:out0",
    "shapelayer:out0"
   ]
  ],
  "acu_lys_alias": [
   "shapelayer"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "shapelayer:in0"
   ]
  ],
  "ruler_name": "r_shape",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Shape:in0"
   ]
  ],
  "src_ops_alias": [
   "Shape"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "Shape:out0"
  ],
  "param_map": {
   "shapelayer": {
    "out_type": [
     "STRING",
     "CODE",
     "self.dtype_pick(tensor['Shape:out0'])"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Sign:out0",
    "sign:out0"
   ]
  ],
  "acu_lys_alias": [
   "sign"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "sign:in0"
   ]
  ],
  "ruler_name": "r_sign",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Sign:in0"
   ]
  ],
  "src_ops_alias": [
   "Sign"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "Sign:out0"
  ],
  "param_map": {},
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "Size:out0",
    "size:out0"
   ]
  ],
  "acu_lys_alias": [
   "size"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "size:in0"
   ]
  ],
  "ruler_name": "r_size",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "Size:in0"
   ]
  ],
  "src_ops_alias": [
   "Size"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "Size:out0"
  ],
  "param_map": {
   "size": {
    "out_type": [
     "STRING",
     "CODE",
     "self.dtype_pick(tensor['Size:out0'])"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "ScatterND:out0",
    "scatter_nd_update:out0"
   ]
  ],
  "acu_lys_alias": [
   "scatter_nd_update"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "scatter_nd_update:in0"
   ],
   [
    "I_1:out0",
    "scatter_nd_update:in1"
   ],
   [
    "I_2:out0",
    "scatter_nd_update:in2"
   ]
  ],
  "ruler_name": "r_scatter_nd",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "ScatterND:in0"
   ],
   [
    "I_1:out0",
    "ScatterND:in1"
   ],
   [
    "I_2:out0",
    "ScatterND:in2"
   ]
  ],
  "src_ops_alias": [
   "ScatterND"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "ScatterND:out0"
  ],
  "param_map": {},
  "src_inter_flow": [],
  "acu_inter_flow": []
 },
 {
  "src_ops_main_version": null,
  "src_ops_minior_version": [
   1,
   -1
  ],
  "src_acu_out_tensor_map": [
   [
    "MeanVarianceNormalization:out0",
    "instancenormalize:out0"
   ]
  ],
  "acu_lys_alias": [
   "instancenormalize"
  ],
  "src_acu_in_tensor_map": [
   [
    "I:out0",
    "instancenormalize:in0"
   ]
  ],
  "ruler_name": "r_mean_variance_normalization",
  "priority_tip": 0,
  "src_in_anchor": [
   [
    "I:out0",
    "MeanVarianceNormalization:in0"
   ]
  ],
  "src_ops_alias": [
   "MeanVarianceNormalization"
  ],
  "blob_map": {},
  "pre_condition": null,
  "src_out_tensor": [
   "MeanVarianceNormalization:out0"
  ],
  "param_map": {
   "instancenormalize": {
    "axis": [
     "INTS",
     "CODE",
     "[p for p in self.attr_pick(node['MeanVarianceNormalization'], 'axes', [0, 2, 3])]"
    ]
   }
  },
  "src_inter_flow": [],
  "acu_inter_flow": []
 }
]